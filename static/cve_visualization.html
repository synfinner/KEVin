<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE Visualization</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!-- Font Awesome for icons -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Layout */
        .navbar-brand {
            font-weight: 700;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            transition: background-color 0.3s, color 0.3s;
            color: #333;
        }

        body.bg-dark {
            background: linear-gradient(to right, #1a1a1a, #333);
            color: #E0E0E0;
        }

        #chart {
            width: 100%;
            height: 800px;
            margin: 20px auto;
            border: none;
            border-radius: 15px;
            background-color: #fff;
            position: relative;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            max-width: 1600px;
            overflow: hidden;
        }

        body.bg-dark #chart {
            background-color: #2C2C2C;
            border-color: #444;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            padding: 10px;
            font: 14px sans-serif;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        body.bg-dark .tooltip {
            background: rgba(68, 68, 68, 0.95);
            color: #E0E0E0;
        }

        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            transition: transform 0.2s;
        }

        body.bg-dark .node {
            stroke: #444;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s;
        }

        body.bg-dark .link {
            stroke: #666;
        }

        .label {
            font-size: 14px;
            pointer-events: none;
            color: #000;
            /* Improve readability with a light stroke halo */
            paint-order: stroke fill;
            stroke: rgba(255, 255, 255, 0.85);
            stroke-width: 3px;
        }

        body.bg-dark .label {
            color: #E0E0E0;
            stroke: rgba(0, 0, 0, 0.85);
        }

        .info-box {
            position: absolute;
            width: 350px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            font-size: 14px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1001;
        }

        body.bg-dark .info-box {
            background: #2C2C2C;
            border-color: #444;
            color: #E0E0E0;
        }

        .info-box h5 {
            margin-top: 0;
        }

        .hero-panel {
            max-width: 1200px;
            margin: 0 auto 32px;
            padding: 36px 42px 30px;
            border-radius: 40px;
            background: linear-gradient(140deg, rgba(255, 255, 255, 0.92), rgba(235, 240, 255, 0.88));
            box-shadow: 0 22px 60px rgba(15, 40, 80, 0.15);
            position: relative;
        }

        body.bg-dark .hero-panel {
            background: linear-gradient(140deg, rgba(38, 41, 55, 0.92), rgba(24, 24, 24, 0.95));
            box-shadow: 0 26px 70px rgba(0, 0, 0, 0.6);
        }

        .hero-panel::after {
            content: '';
            position: absolute;
            inset: 12px;
            border-radius: 32px;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0));
            pointer-events: none;
            z-index: 0;
        }

        body.bg-dark .hero-panel::after {
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0));
        }

        .hero-panel > * {
            position: relative;
            z-index: 1;
        }

        .control-stack {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-top: 24px;
        }

        .control-row {
            background: rgba(255, 255, 255, 0.72);
            border-radius: 28px;
            padding: 14px 24px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65), 0 10px 25px rgba(15, 40, 80, 0.08);
        }

        body.bg-dark .control-row {
            background: rgba(40, 42, 50, 0.85);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 14px 28px rgba(0, 0, 0, 0.35);
        }

        .control-row.secondary {
            padding: 18px 24px;
        }

        .control-row.secondary .custom-control {
            margin-bottom: 0;
        }

        .control-row.secondary .custom-control-label {
            font-size: 0.95rem;
        }

        .graph-surface {
            display: flex;
            gap: 24px;
            align-items: stretch;
        }

        .graph-main {
            position: relative;
            flex: 1 1 auto;
            min-height: 820px;
        }

        .graph-sidebar {
            width: 310px;
            background: rgba(255, 255, 255, 0.78);
            border-radius: 28px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 14px 35px rgba(15, 40, 80, 0.08);
            padding: 20px 22px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        body.bg-dark .graph-sidebar {
            background: rgba(38, 40, 50, 0.9);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 16px 40px rgba(0, 0, 0, 0.5);
        }

        .sidebar-section {
            background: rgba(255, 255, 255, 0.65);
            border-radius: 20px;
            padding: 16px 18px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        body.bg-dark .sidebar-section {
            background: rgba(28, 30, 40, 0.72);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .sidebar-section h5 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .focus-title {
            font-size: 1.05rem;
            font-weight: 600;
        }

        .focus-tabs {
            display: inline-flex;
            border-radius: 18px;
            padding: 4px;
            background: rgba(0,0,0,0.05);
            margin-top: 10px;
            margin-bottom: 12px;
        }

        body.bg-dark .focus-tabs {
            background: rgba(255, 255, 255, 0.08);
        }

        .focus-tab {
            border: none;
            background: transparent;
            font-size: 0.82rem;
            padding: 6px 14px;
            border-radius: 14px;
            cursor: pointer;
            color: #4f5d78;
        }

        .focus-tab.active {
            background: #0052cc;
            color: #fff;
            box-shadow: 0 4px 14px rgba(0, 82, 204, 0.2);
        }

        body.bg-dark .focus-tab {
            color: #cbd7ff;
        }

        body.bg-dark .focus-tab.active {
            background: #82a7ff;
            color: #0d1c3f;
        }

        .focus-neighbors-wrapper {
            max-height: 220px;
            overflow: hidden;
        }

        .focus-section-hidden {
            display: none;
        }

        .focus-meta {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px 12px;
            font-size: 0.9rem;
        }

        .focus-meta span {
            display: block;
            color: #4f5d78;
        }

        .focus-meta strong {
            display: block;
            font-weight: 600;
            color: #1d2f4a;
        }

        body.bg-dark .focus-meta span {
            color: #cbd7ff;
        }

        body.bg-dark .focus-meta strong {
            color: #fff;
        }

        .focus-neighbors {
            margin: 12px 0 0;
            padding-left: 18px;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .focus-neighbors li {
            margin-bottom: 4px;
        }

        .focus-description {
            margin-top: 12px;
            font-size: 0.86rem;
            line-height: 1.4;
        }

        body.bg-dark .focus-description {
            color: #dfe6ff;
        }

        .quick-filters {
            margin-top: 14px;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }

        .severity-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.82rem;
            padding: 6px 10px;
            border-radius: 18px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 0.85);
            box-shadow: 0 4px 12px rgba(15, 40, 80, 0.05);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .severity-chip.active {
            border-color: #0052cc;
            box-shadow: 0 6px 18px rgba(0, 82, 204, 0.18);
        }

        body.bg-dark .severity-chip {
            background: rgba(34, 36, 45, 0.9);
            border-color: rgba(255, 255, 255, 0.12);
            color: #e1e7ff;
        }

        body.bg-dark .severity-chip.active {
            border-color: #82a7ff;
            box-shadow: 0 6px 18px rgba(130, 167, 255, 0.28);
        }

        .severity-chip .dot {
            width: 9px;
            height: 9px;
            border-radius: 50%;
        }

        .delta {
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: auto;
            color: #6c7a99;
        }

        .delta.positive {
            color: #1c7c33;
        }

        .delta.negative {
            color: #b32d2d;
        }

        body.bg-dark .delta {
            color: #c3ccf6;
        }

        .snapshot-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.88rem;
            margin-bottom: 6px;
            align-items: center;
        }

        .snapshot-row strong {
            font-weight: 600;
        }

        .severity-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .snapshot-row.severity-pill {
            justify-content: flex-start;
            gap: 10px;
        }

        .snapshot-row.severity-pill strong {
            min-width: 28px;
        }

        .severity-pill .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .mini-map-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        #miniMap {
            width: 100%;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.85);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
        }

        body.bg-dark #miniMap {
            background: rgba(20, 22, 30, 0.9);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.4);
        }

        .mini-map-hint {
            font-size: 0.8rem;
            color: #6c7a99;
            text-align: center;
        }

        body.bg-dark .mini-map-hint {
            color: #c3ccf6;
        }

        @keyframes nodePulse {
            0% { stroke-width: 6px; stroke-opacity: 0.85; }
            100% { stroke-width: 1.5px; stroke-opacity: 0.2; }
        }

        .node.new-node {
            stroke: rgba(0, 82, 204, 0.7);
            animation: nodePulse 1.1s ease-out;
        }

        .node.is-focus {
            stroke: #0052cc;
            stroke-width: 3px;
        }

        body.bg-dark .node.is-focus {
            stroke: #82a7ff;
        }

        .label.is-focus {
            font-weight: 700;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 0;
            width: 100%;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        :root {
            --control-height: 48px;
            --control-radius: 28px;
        }

        .controls .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            font-size: 16px;
            padding: 0 24px;
            height: var(--control-height);
            border-radius: var(--control-radius);
            border: none;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .controls .btn:focus,
        .controls .btn:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.18);
            transform: translateY(-1px);
        }

        .controls .input-group {
            height: var(--control-height);
            border-radius: var(--control-radius);
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        .controls .input-group .input-group-prepend .input-group-text,
        .controls .input-group .input-group-append .input-group-text {
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 16px;
            border: none;
            background: rgba(0, 0, 0, 0.05);
        }

        body.bg-dark .controls .input-group .input-group-prepend .input-group-text,
        body.bg-dark .controls .input-group .input-group-append .input-group-text {
            background: rgba(255, 255, 255, 0.08);
            color: #dce4ff;
        }

        body.bg-dark .controls .input-group .input-group-prepend .input-group-text,
        body.bg-dark .controls .input-group .input-group-append .input-group-text {
            background: rgba(255, 255, 255, 0.08);
            color: #dce4ff;
        }

        .controls .input-group .form-control,
        .controls .input-group select,
        .controls .input-group input[type="number"],
        .controls .input-group input[type="text"] {
            height: 100%;
            border: none;
            padding: 0 16px;
            font-size: 16px;
            box-shadow: none;
        }

        body.bg-dark .controls .input-group .form-control,
        body.bg-dark .controls .input-group select,
        body.bg-dark .controls .input-group input[type="number"],
        body.bg-dark .controls .input-group input[type="text"] {
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        body.bg-dark .controls .input-group .form-control,
        body.bg-dark .controls .input-group select,
        body.bg-dark .controls .input-group input[type="number"],
        body.bg-dark .controls .input-group input[type="text"] {
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        .controls .form-control,
        .controls select,
        .controls input[type="number"],
        .controls input[type="text"] {
            height: var(--control-height);
            border-radius: var(--control-radius);
            border: 1px solid #ccc;
            font-size: 16px;
            padding: 0 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        body.bg-dark .controls .form-control,
        body.bg-dark .controls select,
        body.bg-dark .controls input[type="number"],
        body.bg-dark .controls input[type="text"] {
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        body.bg-dark .controls .form-control,
        body.bg-dark .controls select,
        body.bg-dark .controls input[type="number"],
        body.bg-dark .controls input[type="text"] {
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        .controls .form-control:focus,
        .controls select:focus,
        .controls input[type="number"]:focus,
        .controls input[type="text"]:focus {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        body.bg-dark .controls .form-control:focus,
        body.bg-dark .controls select:focus,
        body.bg-dark .controls input[type="number"]:focus,
        body.bg-dark .controls input[type="text"]:focus {
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.45);
        }

        body.bg-dark .controls .form-control:focus,
        body.bg-dark .controls select:focus,
        body.bg-dark .controls input[type="number"]:focus,
        body.bg-dark .controls input[type="text"]:focus {
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.45);
        }

        .status-chip-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 12px 0 4px;
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 82, 204, 0.08);
            color: #1d3a6b;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.01em;
            text-transform: uppercase;
        }

        .status-chip.hidden {
            display: none;
        }

        body.bg-dark .status-chip {
            background: rgba(132, 170, 255, 0.18);
            color: #d6e2ff;
        }

        .status-chip[data-variant="warning"] {
            background: rgba(255, 193, 7, 0.15);
            color: #7a5400;
        }

        body.bg-dark .status-chip[data-variant="warning"] {
            background: rgba(255, 193, 7, 0.25);
            color: #ffd267;
        }

        .status-chip[data-variant="danger"] {
            background: rgba(220, 53, 69, 0.15);
            color: #7a1120;
        }

        body.bg-dark .status-chip[data-variant="danger"] {
            background: rgba(220, 53, 69, 0.3);
            color: #ff9aa8;
        }

        .status-chip .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.6;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: #333;
        }

        .header p {
            font-size: 1.2rem;
            color: #666;
        }

        body.bg-dark .header h1 {
            color: #E0E0E0;
        }

        body.bg-dark .header p {
            color: #AAA;
        }

        .custom-switch {
            margin-top: 0;
        }

        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }


        .status-bar {
            margin-top: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            background: rgba(255, 255, 255, 0.78);
            padding: 14px 20px;
            border-radius: 20px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 8px 24px rgba(15, 40, 80, 0.08);
        }

        body.bg-dark .status-bar {
            background: rgba(40, 42, 50, 0.88);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 12px 28px rgba(0, 0, 0, 0.4);
        }

        .status-bar .text-muted {
            color: #2f3d55 !important;
        }

        body.bg-dark .status-bar .text-muted {
            color: #d0d7f5 !important;
        }

        .progress {
            height: 10px;
            background-color: rgba(0, 0, 0, 0.08);
            border-radius: 6px;
        }

        body.bg-dark .progress {
            background-color: rgba(255, 255, 255, 0.12);
        }
        .btn-icon {
            padding: 6px 10px;
        }
        body.bg-dark .btn-outline-dark {
            color: #f5f8ff;
            border-color: rgba(255, 255, 255, 0.25);
        }

        body.bg-dark .btn-outline-dark:hover,
        body.bg-dark .btn-outline-dark:focus {
            background: rgba(255, 255, 255, 0.12);
            color: #f5f8ff;
        }
        .floating-right {
            position: absolute;
            bottom: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        @media (max-width: 992px) {
            .hero-panel {
                padding: 28px 30px 26px;
                border-radius: 32px;
            }
            :root {
                --control-height: 46px;
            }
            .control-group {
                justify-content: center;
            }
            .control-row {
                padding: 16px 18px;
            }
            .status-chip-row {
                gap: 8px;
            }
            .graph-surface {
                flex-direction: column;
            }
            .graph-sidebar {
                width: 100%;
            }
        }

        @media (max-width: 576px) {
            .hero-panel {
                padding: 24px 18px 22px;
            }
            :root {
                --control-height: 44px;
                --control-radius: 22px;
            }
            .controls .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            .controls .btn,
            .controls .input-group,
            .controls .form-control,
            .controls select,
            .controls input[type="number"],
            .controls input[type="text"] {
                width: 100% !important;
            }
            .status-chip-row {
                justify-content: flex-start;
            }
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
            .floating-right {
                right: 6px;
            }
            .quick-filters {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }
    </style>
</head>

<body>
    <!-- Top Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="/">KEVin</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active"><a class="nav-link" href="/graph">Graph</a></li>
                <li class="nav-item"><a class="nav-link" href="/viz">Viz</a></li>
                <li class="nav-item"><a class="nav-link" href="/rss">RSS</a></li>
                <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
            </ul>
            <div class="form-inline my-2 my-lg-0">
                <input id="globalSearch" class="form-control mr-sm-2" type="search" placeholder="Search CVE or Actor" aria-label="Search" style="width: 240px;">
                <button id="globalSearchBtn" class="btn btn-outline-success my-2 my-sm-0" type="button"><i class="fas fa-search"></i></button>
            </div>
        </div>
    </nav>

    <div class="container mt-5">
        <div class="hero-panel">
            <div class="header">
                <h1 class="display-4">CISA KEV CVE Graph by Threat Actors</h1>
                <p class="lead">Explore vulnerabilities and their associated threat actors.</p>
            </div>

            <div class="control-stack">
                <div class="control-row primary">
                    <div class="controls">
                        <div class="control-group">
                            <button class="btn btn-primary" id="fetchData"><i class="fas fa-download"></i> Fetch</button>
                            <button class="btn btn-secondary" id="loadMoreData"><i class="fas fa-plus"></i> More</button>
                            <button class="btn btn-info" id="loadAll"><i class="fas fa-list"></i> Load All</button>
                            <button class="btn btn-info" id="layoutToggle"><i class="fas fa-project-diagram"></i> Organic</button>
                            <button class="btn btn-danger" id="resetView"><i class="fas fa-redo"></i> Reset</button>
                            <div class="input-group" style="width: 220px;">
                                <div class="input-group-prepend"><span class="input-group-text">per_page</span></div>
                                <input type="number" id="perPage" class="form-control" min="1" max="100" value="25">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="control-row secondary">
                    <div class="controls">
                        <div class="control-group">
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="darkThemeToggle">
                                <label class="custom-control-label" for="darkThemeToggle">Dark Theme</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="filterActorsToggle">
                                <label class="custom-control-label" for="filterActorsToggle">Filter Actors</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="labelsToggle" checked>
                                <label class="custom-control-label" for="labelsToggle">Labels</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="sizeByDegreeToggle" checked>
                                <label class="custom-control-label" for="sizeByDegreeToggle">Size by Degree</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="focusModeToggle">
                                <label class="custom-control-label" for="focusModeToggle">Focus Mode</label>
                            </div>
                            <div class="input-group" style="width: 260px;">
                                <div class="input-group-prepend"><span class="input-group-text">Actor</span></div>
                                <input type="text" id="actorSearch" placeholder="Search by Actor" class="form-control">
                                <div class="input-group-append">
                                    <button class="btn btn-success" id="searchByActor"><i class="fas fa-search"></i></button>
                                </div>
                            </div>
                            <button class="btn btn-warning" id="cancelSearch" style="display: none;">Cancel</button>
                            <div class="input-group" style="width: 280px;">
                                <div class="input-group-prepend"><span class="input-group-text">Severity</span></div>
                                <select id="severityFilter" class="form-control">
                                    <option value="all" selected>All</option>
                                    <option value="CRITICAL">Critical</option>
                                    <option value="HIGH">High</option>
                                    <option value="MEDIUM">Medium</option>
                                    <option value="LOW">Low</option>
                                    <option value="UNKNOWN">Unknown</option>
                                </select>
                            </div>
                            <div class="input-group" style="width: 300px;">
                                <div class="input-group-prepend"><span class="input-group-text">Min CVEs</span></div>
                                <input type="range" id="minDegree" class="form-control" min="0" max="10" step="1" value="0" oninput="document.getElementById('minDegreeValue').textContent=this.value">
                                <div class="input-group-append"><span class="input-group-text" id="minDegreeValue">0</span></div>
                            </div>
                            <button class="btn btn-outline-dark" id="exitFocus" style="display:none;">Exit Focus</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="status-chip-row" id="statusChipRow">
                <span class="status-chip" id="chipPage"><span class="dot"></span><span class="label-text">Page 0/?</span></span>
                <span class="status-chip" id="chipLayout"><span class="dot"></span><span class="label-text">Layout: Structured</span></span>
                <span class="status-chip" id="chipSeverity"><span class="dot"></span><span class="label-text">Severity: All</span></span>
                <span class="status-chip" id="chipMinDegree"><span class="dot"></span><span class="label-text">Min CVEs: 0</span></span>
                <span class="status-chip" id="chipActor"><span class="dot"></span><span class="label-text">Actor: All</span></span>
                <span class="status-chip" id="chipLabels"><span class="dot"></span><span class="label-text">Labels: On</span></span>
                <span class="status-chip" id="chipFocus"><span class="dot"></span><span class="label-text">Focus Off</span></span>
            </div>

            <div class="status-bar">
                <div class="text-muted" id="statusText">Idle</div>
                <div class="flex-grow-1">
                    <div class="progress" style="display:none;" id="progressContainer">
                        <div id="loadProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuemin="0" aria-valuemax="100" style="width: 0%">0%</div>
                    </div>
                </div>
                <div class="text-muted" id="countsText">Nodes: 0, Links: 0</div>
            </div>
        </div>

        <div class="graph-surface">
            <div class="graph-main">
                <div id="chart"></div>
                <div class="info-box" id="infoBox"></div>
                <div class="loading-spinner" id="loadingSpinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="sr-only">Loading...</span>
                    </div>
                </div>
                <div class="floating-right">
                    <button class="btn btn-light btn-icon" id="zoomIn" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                    <button class="btn btn-light btn-icon" id="zoomOut" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                    <button class="btn btn-light btn-icon" id="zoomFit" title="Fit to Screen"><i class="fas fa-compress-arrows-alt"></i></button>
                    <button class="btn btn-light btn-icon" id="exportSvg" title="Export SVG"><i class="fas fa-file-download"></i></button>
                </div>
            </div>
            <aside class="graph-sidebar" id="insightPanel">
                <div class="sidebar-section">
                    <h5>Active Focus</h5>
                    <div class="focus-title" id="focusTitle">No selection yet</div>
                    <div class="focus-tabs" id="focusTabs">
                        <button class="focus-tab active" data-tab="overview">Overview</button>
                        <button class="focus-tab" data-tab="neighbors">Neighbors</button>
                    </div>
                    <div id="focusOverview">
                        <div class="focus-meta" id="focusMeta"></div>
                        <div class="focus-description" id="focusDescription"></div>
                    </div>
                    <div id="focusNeighborsSection" class="focus-neighbors-wrapper">
                        <ul class="focus-neighbors" id="focusNeighbors"></ul>
                    </div>
                </div>
                <div class="sidebar-section">
                    <h5>Graph Snapshot</h5>
                    <div class="snapshot-row"><span>Total Nodes: </span><strong id="statNodes">0</strong><span class="delta" id="statNodesDelta"></span></div>
                    <div class="snapshot-row"><span>Total Links: </span><strong id="statLinks">0</strong><span class="delta" id="statLinksDelta"></span></div>
                    <div class="snapshot-row"><span>Actors: </span><strong id="statActors">0</strong><span class="delta" id="statActorsDelta"></span></div>
                    <div class="snapshot-row"><span>CVEs: </span><strong id="statCves">0</strong><span class="delta" id="statCvesDelta"></span></div>
                    <div class="quick-filters" id="severityQuickFilters">
                        <button class="severity-chip active" data-severity="all">All</button>
                        <button class="severity-chip" data-severity="CRITICAL"><span class="dot" style="background:#d62728;"></span>Critical <span id="sevCritical">0</span></button>
                        <button class="severity-chip" data-severity="HIGH"><span class="dot" style="background:#ff7f0e;"></span>High <span id="sevHigh">0</span></button>
                        <button class="severity-chip" data-severity="MEDIUM"><span class="dot" style="background:#ffbf00;"></span>Medium <span id="sevMedium">0</span></button>
                        <button class="severity-chip" data-severity="LOW"><span class="dot" style="background:#2ca02c;"></span>Low <span id="sevLow">0</span></button>
                        <button class="severity-chip" data-severity="UNKNOWN"><span class="dot" style="background:#6baed6;"></span>Unknown <span id="sevUnknown">0</span></button>
                    </div>
                </div>
                <div class="sidebar-section mini-map-card">
                    <h5>Mini Map</h5>
                    <canvas id="miniMap" width="200" height="140"></canvas>
                    <div class="mini-map-hint">Overview of node positions.</div>
                </div>
                <div class="sidebar-section">
                    <h5>Tips</h5>
                    <ul class="focus-neighbors" id="interactionTips"></ul>
                </div>
            </aside>
        </div>

    <script>
        let simulation;
        let currentPage = 1;
        let perPage = 25;
        let allNodes = [];
        let allLinks = [];
        let nodeMap = new Map(); // id -> node
        let linkSet = new Set(); // 'a|b' normalized id pairs
        let adjacency = new Map(); // id -> Set(neighborIds)
        let abortController = null;
        let searchedActor = '';
        let filterActors = false;
        let labelsOn = true;
        let sizeByDegree = true;
        let organicMode = false; // layout style toggle
        let severityFilter = 'all';
        let minDegree = 0;
        let focusMode = false;
        let focusedNodeId = null;
        let rootSvg, zoomBehavior, zoomGroup; // for zoom controls
        let gLinks, gNodes, gLabels; // groups
        let linkSel, nodeSel, labelSel; // selections
        let tooltip, infoBox; // overlays
        let actorLoadTimer = null;
        let loadAllTimer = null;
        let actorLoadActive = false;
        let loadAllActive = false;
        let actorDisplayName = '';
        let pageInfo = { current: 0, total: null };
        const POSITION_STORAGE_KEY = 'kev-graph-pos-v1';
        const MAX_POSITION_STORE = 400;
        const persistedPositions = loadPersistedPositions();
        const SEVERITY_ORDER = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'UNKNOWN'];
        let insightNode = null;
        let miniMapCanvas = null;
        let miniMapCtx = null;
        let miniMapPayload = null;
        let miniMapPending = false;
        let miniMapTick = 0;
        let hasInitialFit = false;
        let currentTransform = d3.zoomIdentity;
        let miniMapState = null;
        let chartWidth = 0;
        let chartHeight = 0;
        let lastSnapshot = null;
        let lastMiniMapNodes = [];
        let activeFocusTab = 'overview';

        document.getElementById('fetchData').addEventListener('click', function () {
            searchedActor = ''; // Clear searched actor when fetching general data
            actorDisplayName = '';
            const actorInput = document.getElementById('actorSearch');
            if (actorInput) actorInput.value = '';
            resetProgress();
            fetchData(currentPage);
            updateStatusChips();
        });

        document.getElementById('loadMoreData').addEventListener('click', function () {
            currentPage++;
            fetchData(currentPage);
        });

        document.getElementById('loadAll').addEventListener('click', function () {
            searchedActor = '';
            actorDisplayName = '';
            const actorInput = document.getElementById('actorSearch');
            if (actorInput) actorInput.value = '';
            startLoadAll();
            updateStatusChips();
        });

        document.getElementById('resetView').addEventListener('click', function () {
            stopSimulation();
            cancelCurrentRequest();
            cancelActorLoad();
            cancelLoadAll();
            d3.select("#chart").selectAll("*").remove();
            allNodes = [];
            allLinks = [];
            nodeMap.clear();
            linkSet.clear();
            adjacency.clear();
            currentPage = 1;
            searchedActor = ''; // Clear searched actor on reset
            minDegree = 0;
            const minSlider = document.getElementById('minDegree');
            const minLabel = document.getElementById('minDegreeValue');
            if (minSlider) { minSlider.value = 0; }
            if (minLabel) { minLabel.textContent = '0'; }
            updateCounts();
            setStatus('Reset. Ready.');
            hideLoadingSpinner();
            hideProgress();
            document.getElementById('cancelSearch').style.display = 'none';
            actorDisplayName = '';
            pageInfo = { current: 0, total: null };
            hasInitialFit = false;
            rootSvg = null; zoomBehavior = null; zoomGroup = null;
            gLinks = gNodes = gLabels = null;
            linkSel = nodeSel = labelSel = null;
            tooltip = infoBox = null;
            updateStatusChips();
            refreshSidebarFocus();
            updateGraphSnapshot([], []);
            scheduleMiniMapRender([]);
        });

        document.getElementById('searchByActor').addEventListener('click', function () {
            cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
            const actorInput = document.getElementById('actorSearch');
            actorDisplayName = actorInput.value.trim();
            searchedActor = actorDisplayName.toLowerCase(); // Store the searched actor in lowercase
            fetchDataByActor(searchedActor);
            updateStatusChips();
            refreshSidebarFocus();
        });

        document.getElementById('cancelSearch').addEventListener('click', function () {
            cancelCurrentRequest(); // Cancel any ongoing request
            cancelActorLoad();
            document.getElementById('cancelSearch').style.display = 'none';
            hideProgress();
            setStatus('Canceled.');
            actorDisplayName = '';
            updateStatusChips();
            refreshSidebarFocus();
        });

        document.getElementById('actorSearch').addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
                actorDisplayName = document.getElementById('actorSearch').value.trim();
                searchedActor = actorDisplayName.toLowerCase(); // Store the searched actor in lowercase
                fetchDataByActor(searchedActor);
                updateStatusChips();
                refreshSidebarFocus();
            }
        });

        document.getElementById('filterActorsToggle').addEventListener('change', function () {
            filterActors = this.checked;
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
        });

        document.getElementById('labelsToggle').addEventListener('change', function () {
            labelsOn = this.checked;
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
        });

        document.getElementById('sizeByDegreeToggle').addEventListener('change', function () {
            sizeByDegree = this.checked;
            visualizeData({ nodes: allNodes, links: allLinks });
        });

        document.getElementById('severityFilter').addEventListener('change', function () {
            severityFilter = this.value;
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
            const container = document.getElementById('severityQuickFilters');
            if (container) {
                const btn = container.querySelector(`.severity-chip[data-severity="${severityFilter}"]`);
                if (btn) btn.classList.add('active');
            }
        });

        document.getElementById('perPage').addEventListener('change', function () {
            const val = parseInt(this.value, 10);
            perPage = Math.max(1, Math.min(100, isNaN(val) ? 25 : val));
            this.value = perPage;
        });

        document.getElementById('minDegree').addEventListener('input', function(){
            minDegree = parseInt(this.value, 10) || 0;
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
        });

        document.getElementById('focusModeToggle').addEventListener('change', function(){
            focusMode = this.checked;
            if (!focusMode) {
                focusedNodeId = null;
                document.getElementById('exitFocus').style.display = 'none';
            }
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
            refreshSidebarFocus();
        });

        (function bindSeverityQuickFilters(){
            const container = document.getElementById('severityQuickFilters');
            if (!container) return;
            container.addEventListener('click', (event) => {
                const btn = event.target.closest('.severity-chip');
                if (!btn) return;
                const value = btn.getAttribute('data-severity');
                if (!value) return;
                severityFilter = value;
                const select = document.getElementById('severityFilter');
                if (select) select.value = value;
                visualizeData({ nodes: allNodes, links: allLinks });
                updateStatusChips();
            });
        })();

        (function bindFocusTabs(){
            const tabsContainer = document.getElementById('focusTabs');
            if (!tabsContainer) return;
            tabsContainer.addEventListener('click', (event) => {
                const btn = event.target.closest('.focus-tab');
                if (!btn) return;
                const tab = btn.getAttribute('data-tab');
                if (!tab) return;
                activeFocusTab = tab;
                applyFocusTabState();
            });
            applyFocusTabState();
        })();

        document.getElementById('exitFocus').addEventListener('click', function(){
            focusedNodeId = null;
            document.getElementById('exitFocus').style.display = 'none';
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
            refreshSidebarFocus();
        });

        // Navbar global search (CVE or Actor)
        document.getElementById('globalSearchBtn').addEventListener('click', () => {
            const q = document.getElementById('globalSearch').value.trim();
            if (!q) return;
            if (/^CVE-\d{4}-\d{4,}$/.test(q.toUpperCase())) {
                // zoom to CVE label if present
                focusOnNodeById(q.toUpperCase());
            } else {
                // treat as actor search
                document.getElementById('actorSearch').value = q;
                actorDisplayName = q;
                searchedActor = q.toLowerCase();
                fetchDataByActor(searchedActor);
                updateStatusChips();
                refreshSidebarFocus();
            }
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => zoomBy(1.2));
        document.getElementById('zoomOut').addEventListener('click', () => zoomBy(1/1.2));
        document.getElementById('zoomFit').addEventListener('click', () => fitToScreen());
        document.getElementById('exportSvg').addEventListener('click', () => exportSVG());

        // Layout toggle (Organic vs Structured)
        document.getElementById('layoutToggle').addEventListener('click', function(){
            organicMode = !organicMode;
            const btn = document.getElementById('layoutToggle');
            btn.classList.toggle('btn-success', organicMode);
            btn.classList.toggle('btn-info', !organicMode);
            btn.innerHTML = organicMode ? '<i class="fas fa-project-diagram"></i> Organic On' : '<i class="fas fa-project-diagram"></i> Organic';
            setStatus(organicMode ? 'Organic layout' : 'Structured layout');
            visualizeData({ nodes: allNodes, links: allLinks });
            updateStatusChips();
        });

        function cancelCurrentRequest() {
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
        }

        function stopSimulation() {
            if (!simulation) return;
            simulation.stop();
            simulation.on('tick', null); // drop tick callback to avoid updates against cleared selections
            simulation = null;
        }

        function cancelActorLoad() {
            actorLoadActive = false;
            if (actorLoadTimer) {
                clearTimeout(actorLoadTimer);
                actorLoadTimer = null;
            }
        }

        function cancelLoadAll() {
            loadAllActive = false;
            if (loadAllTimer) {
                clearTimeout(loadAllTimer);
                loadAllTimer = null;
            }
        }

        function fetchData(page) {
            showLoadingSpinner();
            cancelActorLoad();
            cancelLoadAll();
            cancelCurrentRequest();
            const ctrl = new AbortController();
            abortController = ctrl;
            const signal = ctrl.signal;

            fetch(`/kev?page=${page}&per_page=${perPage}`, { signal })
                .then(response => response.json())
                .then(data => {
                    hideLoadingSpinner();
                    if (signal.aborted) return; // Check if the request was aborted
                    const formattedData = formatData(data.vulnerabilities);
                    mergeGraph(formattedData.nodes, formattedData.links);
                    visualizeData({ nodes: allNodes, links: allLinks });
                    updateCounts();
                    setStatus(`Page ${data.page}/${data.total_pages || '?'} loaded.`);
                    const current = typeof data.page === 'number' ? data.page : page;
                    pageInfo = {
                        current,
                        total: typeof data.total_pages === 'number' ? data.total_pages : pageInfo.total
                    };
                    updateStatusChips();
                })
                .catch(error => {
                    hideLoadingSpinner();
                    if (error.name === 'AbortError') {
                        console.log('Fetch request canceled');
                    } else {
                        console.error('Error fetching data:', error);
                        setStatus('Error fetching data');
                    }
                });
        }

        function fetchDataByActor(actor) {
            showLoadingSpinner();
            cancelActorLoad();
            cancelLoadAll();
            cancelCurrentRequest();
            const ctrl = new AbortController();
            abortController = ctrl;
            const signal = ctrl.signal;

            const encodedActor = encodeURIComponent(actor);
            fetch(`/kev?actor=${encodedActor}&page=${currentPage}&per_page=${perPage}`, { signal })
                .then(response => response.json())
                .then(data => {
                    hideLoadingSpinner();
                    if (signal.aborted) return; // Check if the request was aborted
                    const formattedData = formatData(data.vulnerabilities);
                    mergeGraph(formattedData.nodes, formattedData.links);
                    visualizeData({ nodes: allNodes, links: allLinks });

                    // Show cancel button
                    document.getElementById('cancelSearch').style.display = 'inline-block';
                    setStatus(`Loaded page ${data.page}/${data.total_pages} for actor: ${actor}`);
                    showProgress();
                    updateProgress(data.page, data.total_pages);
                    pageInfo = {
                        current: typeof data.page === 'number' ? data.page : (pageInfo.current || 1),
                        total: typeof data.total_pages === 'number' ? data.total_pages : pageInfo.total
                    };
                    updateStatusChips();

                    // Automatically load subsequent pages if total_pages > 1
                    if (data.total_pages > 1) {
                        loadMoreDataByActor(actor, data.total_pages);
                    }
                })
                .catch(error => {
                    hideLoadingSpinner();
                    if (error.name === 'AbortError') {
                        console.log('Fetch request canceled');
                    } else {
                        console.error('Error fetching data:', error);
                        setStatus('Error fetching actor data');
                    }
                });
        }

        function loadMoreDataByActor(actor, totalPages) {
            let page = 2;
            actorLoadActive = true;
            const encodedActor = encodeURIComponent(actor);

            const fetchPage = () => {
                if (!actorLoadActive) return;
                if (page > totalPages) {
                    actorLoadActive = false;
                    if (actorLoadTimer) {
                        clearTimeout(actorLoadTimer);
                        actorLoadTimer = null;
                    }
                    return; // End recursion
                }

                cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
                const ctrl = new AbortController();
                abortController = ctrl;
                const signal = ctrl.signal;

                fetch(`/kev?actor=${encodedActor}&page=${page}&per_page=${perPage}`, { signal })
                    .then(response => response.json())
                    .then(data => {
                        if (!actorLoadActive || signal.aborted) return;
                        const formattedData = formatData(data.vulnerabilities);
                        mergeGraph(formattedData.nodes, formattedData.links);
                        visualizeData({ nodes: allNodes, links: allLinks });
                        updateCounts();
                        showProgress();
                        updateProgress(page, totalPages);
                        pageInfo = { current: page, total: totalPages };
                        updateStatusChips();
                        page++;
                        actorLoadTimer = setTimeout(() => {
                            actorLoadTimer = null;
                            fetchPage();
                        }, 1500); // 1.5s pause to avoid rate limits
                    })
                    .catch(error => {
                        actorLoadActive = false;
                        if (actorLoadTimer) {
                            clearTimeout(actorLoadTimer);
                            actorLoadTimer = null;
                        }
                        if (error.name === 'AbortError') {
                            console.log('Fetch request canceled');
                        } else {
                            console.error('Error fetching data:', error);
                            setStatus('Error while loading more pages');
                        }
                    });
            };

            fetchPage(); // Start fetching pages
        }

        function startLoadAll() {
            showProgress();
            cancelLoadAll();
            cancelActorLoad();
            cancelCurrentRequest();
            const ctrl = new AbortController();
            abortController = ctrl;
            const signal = ctrl.signal;
            loadAllActive = true;
            loadAllTimer = null;
            // First call to get total pages
            fetch(`/kev?page=1&per_page=${perPage}`, { signal })
                .then(r => r.json())
                .then(first => {
                    if (!loadAllActive || signal.aborted) return;
                    const formatted = formatData(first.vulnerabilities);
                    mergeGraph(formatted.nodes, formatted.links);
                    visualizeData({ nodes: allNodes, links: allLinks });
                    updateCounts();
                    const totalPages = first.total_pages;
                    updateProgress(1, totalPages);
                    setStatus(`Loading all pages: 1/${totalPages}`);
                    pageInfo = { current: 1, total: totalPages || pageInfo.total };
                    updateStatusChips();
                    // Sequentially fetch remaining pages
                    let p = 2;
                    const loop = () => {
                        if (!loadAllActive) return;
                        if (p > totalPages) {
                            loadAllActive = false;
                            if (loadAllTimer) {
                                clearTimeout(loadAllTimer);
                                loadAllTimer = null;
                            }
                            setStatus('All pages loaded.');
                            hideProgress();
                            pageInfo = { current: totalPages, total: totalPages };
                            updateStatusChips();
                            fitToScreen();
                            return;
                        }
                        cancelCurrentRequest();
                        const ctrl2 = new AbortController();
                        abortController = ctrl2;
                        const sig = ctrl2.signal;
                        fetch(`/kev?page=${p}&per_page=${perPage}`, { signal: sig })
                            .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
                            .then(data => {
                                if (sig.aborted) return;
                                if (!loadAllActive) return;
                                const f = formatData(data.vulnerabilities);
                                mergeGraph(f.nodes, f.links);
                                visualizeData({ nodes: allNodes, links: allLinks });
                                updateCounts();
                                updateProgress(p, totalPages);
                                setStatus(`Loading all pages: ${p}/${totalPages}`);
                                pageInfo = { current: p, total: totalPages };
                                updateStatusChips();
                                p++;
                                loadAllTimer = setTimeout(() => {
                                    loadAllTimer = null;
                                    loop();
                                }, 1500); // 1.5s pause to avoid rate limits
                            })
                            .catch(err => {
                                loadAllActive = false;
                                if (loadAllTimer) {
                                    clearTimeout(loadAllTimer);
                                    loadAllTimer = null;
                                }
                                if (err.name !== 'AbortError') {
                                    console.error(err);
                                    setStatus('Error during Load All');
                                }
                            });
                    };
                    loop();
                })
                .catch(err => {
                    loadAllActive = false;
                    if (loadAllTimer) {
                        clearTimeout(loadAllTimer);
                        loadAllTimer = null;
                    }
                    if (err.name !== 'AbortError') {
                        console.error(err);
                        setStatus('Error starting Load All');
                    }
                });
        }

        // Helpers to parse and normalize actor names that may be comma-separated
        function normalizeActorName(name) {
            if (!name && name !== 0) return null;
            let s = ('' + name).trim();
            // strip quotes and collapse spaces
            s = s.replace(/^['"\s]+|['"\s]+$/g, '').replace(/\s+/g, ' ');
            return s.length ? s : null;
        }

        // Actor exclusions: easily extendable lists
        const ACTOR_EXACT_EXCLUDE = [
            'vulnerability advisory',
            'n/a',
            'unknown',
            'malware advisory',
            'threat',
            'informational',
            'threat analysis',
            'a few critical',
            'kaseya vsa',
            'The State of Colorado'
        ];
        const ACTOR_CONTAINS_EXCLUDE = [
            'brian sabey',
            'threat intel report',
            'ioc-'
        ];

        function shouldExcludeActor(name) {
            if (name == null) return true;
            const val = ('' + name).trim().toLowerCase();
            if (!val) return true;
            if (ACTOR_EXACT_EXCLUDE.includes(val)) return true;
            for (const sub of ACTOR_CONTAINS_EXCLUDE) {
                if (val.includes(sub)) return true;
            }
            return false;
        }

        // Canonical mapping for vendor-specific actor names (lowercase keys)
        // Extend this as needed to unify naming across data sources
        const ACTOR_CANONICAL_MAP = {
            'lazarus': 'Lazarus',
            'lazarus group': 'Lazarus',
            'clop': 'cl0p',
            'xe': 'XE Group',
            'xe group': 'XE Group',
            'wannacry': 'WannaCry',
            'turla group': 'Turla',
            'krypton': 'Turla',
            'venomous bear': 'Turla',
            'uroburos': 'Turla',
            'andariel': 'Onyx Sleet',
            'silent chollima': 'Onyx Sleet',
            'chollima': 'Onyx Sleet',
            'plutonium': 'Onyx Sleet'
        };

        function canonicalizeActorName(name) {
            if (!name) return name;
            const key = ('' + name).trim().toLowerCase();
            return ACTOR_CANONICAL_MAP[key] || name;
        }

        function splitActorField(value) {
            if (value == null) return [];
            const raw = '' + value;
            if (raw.includes(',')) {
                return raw
                    .split(',')
                    .map(normalizeActorName)
                    .filter(Boolean)
                    .filter(n => !shouldExcludeActor(n))
                    .map(canonicalizeActorName);
            }
            const single = normalizeActorName(raw);
            return single && !shouldExcludeActor(single) ? [canonicalizeActorName(single)] : [];
        }

        function extractActors(threatData) {
            const srcA = Array.isArray(threatData?.adversaries) ? threatData.adversaries : [];
            const srcC = Array.isArray(threatData?.communityAdversaries) ? threatData.communityAdversaries : [];
            const collected = [];
            for (const entry of [...srcA, ...srcC]) {
                if (Array.isArray(entry)) {
                    for (const sub of entry) collected.push(...splitActorField(sub));
                } else {
                    collected.push(...splitActorField(entry));
                }
            }
            // de-duplicate case-insensitively, preserve first casing
            const seen = new Set();
            const out = [];
            for (const n of collected) {
                const key = n.toLowerCase();
                if (!seen.has(key)) { seen.add(key); out.push(n); }
            }
            return out;
        }

        const MAX_DESCRIPTION_LENGTH = 500;
        const MAX_GITHUB_POC_LINKS = 10;

        function compactCveDetails(vuln) {
            if (!vuln) {
                return {
                    cveID: 'Unknown',
                    vulnerabilityName: 'Unknown',
                    severity: 'UNKNOWN',
                    dateAdded: 'Unknown',
                    shortDescription: '',
                    githubPocs: []
                };
            }
            const severity = (vuln.nvdData?.[0]?.baseSeverity || 'UNKNOWN').toUpperCase();
            const pocSet = new Set();
            const pocList = [];
            if (Array.isArray(vuln.githubPocs)) {
                for (const poc of vuln.githubPocs) {
                    if (typeof poc !== 'string') continue;
                    const trimmed = poc.trim();
                    if (!trimmed || pocSet.has(trimmed)) continue;
                    pocSet.add(trimmed);
                    pocList.push(trimmed);
                    if (pocList.length >= MAX_GITHUB_POC_LINKS) break;
                }
            }
            const desc = vuln.shortDescription || '';
            const truncatedDesc = desc.length > MAX_DESCRIPTION_LENGTH ? desc.slice(0, MAX_DESCRIPTION_LENGTH) + '...' : desc;
            return {
                cveID: vuln.cveID,
                vulnerabilityName: vuln.vulnerabilityName || vuln.cveID || 'Unknown',
                severity,
                dateAdded: vuln.dateAdded || 'Unknown',
                shortDescription: truncatedDesc,
                githubPocs: pocList
            };
        }

        function formatData(vulnerabilities) {
            const nodes = [];
            const links = [];
            const actorMap = new Map();

            vulnerabilities.forEach(vuln => {
                const threatData = vuln.openThreatData?.[0] || {};
                const actors = extractActors(threatData);

                if (actors.length > 0) {
                    const cveNode = { id: vuln.cveID, name: vuln.cveID, type: 'cve', details: compactCveDetails(vuln) };
                    nodes.push(cveNode);

                    actors.forEach(actorName => {
                        const actor = actorName; // already normalized
                        const actorNode = { id: actor, name: actor, type: 'actor' };
                        if (!actorMap.has(actor)) {
                            actorMap.set(actor, actorNode);
                            nodes.push(actorNode);
                        }
                        // Direction should show actor influencing CVE, so orient edges actor -> CVE
                        links.push({ source: actor, target: cveNode.id });
                    });
                }
            });

            return { nodes, links };
        }

        // Update the visualizeData function to filter nodes based on the searched actor
        function visualizeData(data) {
            // 1) Filter data
            let filteredNodes = data.nodes;
            let filteredLinks = data.links;
            miniMapTick = 0;

            // Filter nodes and links if the filter toggle is active
            if (filterActors && searchedActor) {
                // Find all actor nodes that match the search term
                const matchingActors = filteredNodes.filter(node => node.type === 'actor' && node.name.toLowerCase().includes(searchedActor));

                // Collect IDs of the matching actors
                const matchingActorIds = new Set(matchingActors.map(actor => actor.id));

                // Filter the nodes to include only CVEs and the matching actors
                filteredNodes = filteredNodes.filter(node => node.type === 'cve' || matchingActorIds.has(node.id));

                // Create a set of matching node IDs
                const matchingNodeIds = new Set(filteredNodes.map(node => node.id));

                // Filter links to include only those that connect to the matching nodes
                filteredLinks = filteredLinks.filter(link => {
                    const s = getLinkEndId(link.source);
                    const t = getLinkEndId(link.target);
                    return matchingNodeIds.has(s) && matchingNodeIds.has(t);
                });
            }

            // Filter by severity (for CVE nodes only)
            if (severityFilter !== 'all') {
                const keep = new Set(filteredNodes.filter(n => {
                    if (n.type !== 'cve') return true;
                    const sev = n.details?.severity || 'UNKNOWN';
                    return sev === severityFilter;
                }).map(n => n.id));
                filteredNodes = filteredNodes.filter(n => keep.has(n.id));
                filteredLinks = filteredLinks.filter(l => keep.has(getLinkEndId(l.source)) && keep.has(getLinkEndId(l.target)));
            }

            // Actor min-CVEs filter (actors only). Compute actor->num CVEs and filter.
            const actorCveCounts = computeActorCveCounts(filteredNodes, filteredLinks);
            // Dynamically adapt slider max to current dataset
            updateMinCveSlider(actorCveCounts);
            if (minDegree > 0) {
                const actorsToKeep = new Set(filteredNodes
                    .filter(n => n.type !== 'actor' || (actorCveCounts.get(n.id) || 0) >= minDegree)
                    .map(n => n.id));
                filteredNodes = filteredNodes.filter(n => actorsToKeep.has(n.id));
                filteredLinks = filteredLinks.filter(l => actorsToKeep.has(getLinkEndId(l.source)) && actorsToKeep.has(getLinkEndId(l.target)));
                // Drop isolated CVEs
                const idsInLinks = new Set();
                for (const l of filteredLinks) { idsInLinks.add(getLinkEndId(l.source)); idsInLinks.add(getLinkEndId(l.target)); }
                filteredNodes = filteredNodes.filter(n => idsInLinks.has(n.id));
            }

            // Focus mode: keep only focused node + its neighbors
            if (focusMode && focusedNodeId) {
                const allowed = new Set([focusedNodeId]);
                (adjacency.get(focusedNodeId) || new Set()).forEach(id => allowed.add(id));
                filteredNodes = filteredNodes.filter(n => allowed.has(n.id));
                filteredLinks = filteredLinks.filter(l => allowed.has(getLinkEndId(l.source)) && allowed.has(getLinkEndId(l.target)));
            }

            updateGraphSnapshot(filteredNodes, filteredLinks);

            const width = document.getElementById('chart').clientWidth;
            const height = document.getElementById('chart').clientHeight;
            chartWidth = width;
            chartHeight = height;

            ensureScene(width, height);

            // Seed positions for nodes that don't have positions yet
            filteredNodes.forEach(node => {
                if (typeof node.x !== 'number' || typeof node.y !== 'number') {
                    node.x = Math.random() * width;
                    node.y = Math.random() * height;
                }
            });

            computeAdjacency(filteredNodes, filteredLinks);
            const degreeMap = computeDegreeMap(filteredNodes, filteredLinks);
            refreshSidebarFocus();
            scheduleMiniMapRender(filteredNodes);
            // 2) Data join (links)
            const linkKey = d => {
                const s = getLinkEndId(d.source);
                const t = getLinkEndId(d.target);
                return s < t ? `${s}|${t}` : `${t}|${s}`;
            };
            linkSel = gLinks.selectAll('line').data(filteredLinks, linkKey);
            linkSel.exit().remove();
            const linkEnter = linkSel.enter().append('line')
                .attr('class', 'link')
                .attr('stroke-width', 1.5)
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('marker-end', 'url(#arrowhead)');
            linkSel = linkEnter.merge(linkSel).attr('marker-end', 'url(#arrowhead)');

            // 3) Data join (nodes)
            nodeSel = gNodes.selectAll('circle').data(filteredNodes, d => d.id);
            nodeSel.exit().remove();
            const nodeEnter = nodeSel.enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => getRadius(d, degreeMap))
                .attr('fill', d => d.type === 'actor' ? '#ff5733' : severityColor(d))
                .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended))
                .on('mouseover', function(event, d){ mouseover(event, d); highlightNode(d, true); })
                .on('mouseout', function(event, d){ mouseout(event, d); highlightNode(d, false); })
                .on('click', function(event, d){
                    if (focusMode) {
                        focusedNodeId = d.id;
                        document.getElementById('exitFocus').style.display = 'inline-block';
                        setStatus(`Focused on ${d.name}`);
                        setInsightNode(d);
                        visualizeData({ nodes: allNodes, links: allLinks });
                        updateStatusChips();
                        return;
                    }
                    setInsightNode(d);
                });
            const newNodes = nodeEnter.filter(d => d.__fresh);
            newNodes.classed('new-node', true).each(function(d){
                d.__fresh = false;
                const el = d3.select(this);
                setTimeout(() => el.classed('new-node', false), 1300);
            });

            nodeSel = nodeEnter.merge(nodeSel)
                .attr('r', d => getRadius(d, degreeMap))
                .attr('fill', d => d.type === 'actor' ? '#ff5733' : severityColor(d));

            // 4) Data join (labels)
            labelSel = gLabels.selectAll('text').data(filteredNodes, d => d.id);
            labelSel.exit().remove();
            const labelEnter = labelSel.enter().append('text')
                .attr('class', 'label')
                .attr('dx', 12)
                .attr('dy', '.35em')
                .text(d => d.name);
            labelSel = labelEnter.merge(labelSel)
                .style('fill', d => body.classList.contains('bg-dark') ? '#E0E0E0' : '#000')
                .style('font-weight', d => searchedActor && (d.name.toLowerCase() === searchedActor || d.name.toLowerCase().includes(searchedActor)) ? 'bold' : 'normal')
                .style('font-size', d => searchedActor && (d.name.toLowerCase() === searchedActor || d.name.toLowerCase().includes(searchedActor)) ? '20px' : '12px')
                .style('display', labelsOn || focusMode ? null : 'none');

            // 5) Init or update simulation
            if (!simulation) {
                simulation = d3.forceSimulation(filteredNodes)
                    .force('link', d3.forceLink(filteredLinks).id(d => d.id).distance(d => getLinkDistance(d)).strength(0.6))
                    .force('charge', d3.forceManyBody().strength(-120))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(d => getRadius(d, degreeMap) + 6).strength(1))
                    .on('end', persistNodePositions);
            }

            simulation.nodes(filteredNodes).on('tick', () => {
                linkSel
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                nodeSel
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                labelSel
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);

                miniMapTick = (miniMapTick + 1) % 4;
                if (miniMapTick === 0) scheduleMiniMapRender(filteredNodes);
            });
            simulation.force('link').links(filteredLinks);
            // apply layout-specific forces
            applyForces(degreeMap, width, height);
            simulation.on('end', persistNodePositions);

            d3.select("body").on("click", function (event) {
                const isOutside = !event.target.closest("#chart") && !event.target.closest(".info-box");
                if (isOutside) {
                    tooltip.transition().duration(300).style("opacity", 0);
                    infoBox.transition().duration(300).style("opacity", 0);
                }
            });

            function mouseover(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.text(d.name)
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
                setInsightNode(d, { persist: false });
            }

            function mouseout(event, d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
                refreshSidebarFocus();
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // Helper: neighbor highlight
            function highlightNode(d, on) {
                const neighbors = adjacency.get(d.id) || new Set();
                const opacityNode = on ? 1 : 0.9;
                const opacityFaded = on ? 0.08 : 0.9;
                nodeSel && nodeSel.style('opacity', n => (n.id === d.id || neighbors.has(n.id)) ? opacityNode : opacityFaded);
                labelSel && labelSel.style('opacity', n => (n.id === d.id || neighbors.has(n.id)) ? 1 : (on ? 0.08 : 1));
                linkSel && linkSel
                    .style('opacity', l => (getLinkEndId(l.source) === d.id || getLinkEndId(l.target) === d.id || (neighbors.has(getLinkEndId(l.source)) && neighbors.has(getLinkEndId(l.target)))) ? 0.8 : (on ? 0.05 : 0.6))
                    .style('stroke', l => (getLinkEndId(l.source) === d.id || getLinkEndId(l.target) === d.id) ? '#555' : '#999')
                    .style('stroke-width', l => (getLinkEndId(l.source) === d.id || getLinkEndId(l.target) === d.id) ? 2.5 : 1.5);
            }

            function showInfoBox(event, d) {
                const detail = d.details || {};
                const severityText = detail.severity || 'UNKNOWN';
                const description = detail.shortDescription || 'No description available';
                const githubPocs = Array.isArray(detail.githubPocs) ? detail.githubPocs : [];
                const cveId = (detail.cveID || d.name || '').toString();

                const el = infoBox.node();
                el.innerHTML = '';

                const h = document.createElement('h5');
                h.textContent = detail.vulnerabilityName || d.name || cveId;
                el.appendChild(h);

                const mkP = (label, value) => {
                    const p = document.createElement('p');
                    const b = document.createElement('strong');
                    b.textContent = label + ': ';
                    p.appendChild(b);
                    p.appendChild(document.createTextNode(value || 'Unknown'));
                    return p;
                };
                el.appendChild(mkP('CVE ID', cveId));
                el.appendChild(mkP('Severity', severityText));
                el.appendChild(mkP('Published Date', detail.dateAdded || 'Unknown'));

                const pd = document.createElement('p');
                const bdesc = document.createElement('strong');
                bdesc.textContent = 'Description: ';
                pd.appendChild(bdesc);
                pd.appendChild(document.createTextNode(description));
                el.appendChild(pd);

                const pocWrap = document.createElement('div');
                const pocTitle = document.createElement('strong');
                pocTitle.textContent = 'GitHub PoCs:';
                pocWrap.appendChild(pocTitle);
                const pocList = document.createElement('div');
                pocList.className = 'github-pocs';
                if (githubPocs.length) {
                    const valid = githubPocs.filter(u => /^https?:\/\//i.test(u));
                    valid.forEach((u, i) => {
                        const a = document.createElement('a');
                        a.href = u;
                        a.textContent = u;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer nofollow ugc';
                        pocList.appendChild(a);
                        if (i < valid.length - 1) pocList.appendChild(document.createTextNode(', '));
                    });
                    if (!valid.length) pocList.textContent = 'No GitHub PoCs';
                } else {
                    pocList.textContent = 'No GitHub PoCs';
                }
                pocWrap.appendChild(pocList);
                el.appendChild(pocWrap);

                const actions = document.createElement('div');
                actions.style.marginTop = '8px';
                const mkBtn = (href, cls, icon, text) => {
                    const a = document.createElement('a');
                    a.className = `btn btn-sm ${cls}`;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.href = href;
                    a.innerHTML = `<i class="${icon}"></i> ${text}`;
                    return a;
                };
                const safeCve = /^CVE-\d{4}-\d{4,}$/.test(cveId) ? cveId : '';
                actions.appendChild(mkBtn(`/vuln/${safeCve}/report`, 'btn-outline-primary', 'fas fa-file-alt', 'Report'));
                actions.appendChild(mkBtn(`/vuln/${safeCve}`, 'btn-outline-secondary', 'fas fa-external-link-alt', 'Details'));
                el.appendChild(actions);

                infoBox.style('display', 'block')
                  .style('left', (event.pageX + 10) + 'px')
                  .style('top', (event.pageY - 28) + 'px')
                  .transition().duration(200)
                  .style('opacity', .9);
                event.stopPropagation();
                setInsightNode(d);
            }

            if (!hasInitialFit && filteredNodes.length) {
                hasInitialFit = true;
                setTimeout(() => fitToScreen(), 60);
            }

            updateStatusChips();
        }

        function ensureScene(width, height) {
            if (!rootSvg) {
                rootSvg = d3.select('#chart').append('svg').attr('width', width).attr('height', height);
                // Define arrow marker for link direction
                const defs = rootSvg.append('defs');
                defs.append('marker')
                    .attr('id', 'arrowhead')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 12)
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', '#999')
                    .attr('opacity', 0.7);
                zoomGroup = rootSvg.append('g');
                gLinks = zoomGroup.append('g').attr('class', 'links');
                gNodes = zoomGroup.append('g').attr('class', 'nodes');
                gLabels = zoomGroup.append('g').attr('class', 'labels');
                zoomBehavior = d3.zoom().scaleExtent([0.2, 5]).on('zoom', (event) => {
                    currentTransform = event.transform;
                    zoomGroup.attr('transform', event.transform);
                    scheduleMiniMapRender(lastMiniMapNodes);
                }).wheelDelta(event => {
                const base = event.deltaMode === 1 ? 0.05 : 0.0025;
                return -event.deltaY * base;
                });
                rootSvg.call(zoomBehavior);
                tooltip = d3.select('#chart').append('div').attr('class', 'tooltip');
                infoBox = d3.select('#infoBox');
            } else {
                rootSvg.attr('width', width).attr('height', height);
            }
        }

        const darkThemeToggle = document.getElementById('darkThemeToggle');
        const body = document.body;

        const userThemePreference = localStorage.getItem('darkTheme');
        if (userThemePreference === 'true') {
            body.classList.add('bg-dark');
            body.classList.add('text-light');
            darkThemeToggle.checked = true;
        }

        darkThemeToggle.addEventListener('change', () => {
            if (darkThemeToggle.checked) {
                body.classList.add('bg-dark');
                body.classList.add('text-light');
                localStorage.setItem('darkTheme', 'true');
            } else {
                body.classList.remove('bg-dark');
                body.classList.remove('text-light');
                localStorage.setItem('darkTheme', 'false');
            }
        });

        function showLoadingSpinner() {
            document.getElementById('loadingSpinner').style.display = 'block';
        }

        function hideLoadingSpinner() {
            document.getElementById('loadingSpinner').style.display = 'none';
        }

        // Graph merge + helpers
        function mergeGraph(newNodes, newLinks) {
            // Precompute neighbors present in current graph for seeding positions
            const existingIds = new Set(allNodes.map(n => n.id));
            const neighborMap = new Map(); // id -> Set(neighborIds)
            for (const l of newLinks) {
                const s = typeof l.source === 'string' ? l.source : l.source.id;
                const t = typeof l.target === 'string' ? l.target : l.target.id;
                if (!neighborMap.has(s)) neighborMap.set(s, new Set());
                if (!neighborMap.has(t)) neighborMap.set(t, new Set());
                neighborMap.get(s).add(t);
                neighborMap.get(t).add(s);
            }

            for (const n of newNodes) {
                if (!nodeMap.has(n.id)) {
                    // Seed new node position near an existing neighbor if possible
                    let seeded = false;
                    const stored = persistedPositions.get(n.id);
                    if (stored && typeof stored.x === 'number' && typeof stored.y === 'number') {
                        n.x = stored.x;
                        n.y = stored.y;
                        seeded = true;
                    }
                    const neighSet = neighborMap.get(n.id) || new Set();
                    if (!seeded) {
                        for (const nid of neighSet) {
                            if (existingIds.has(nid)) {
                                const neighbor = nodeMap.get(nid) || allNodes.find(x => x.id === nid);
                                if (neighbor && typeof neighbor.x === 'number' && typeof neighbor.y === 'number') {
                                    const jitter = () => (Math.random() - 0.5) * 40;
                                    n.x = neighbor.x + jitter();
                                    n.y = neighbor.y + jitter();
                                    seeded = true;
                                    break;
                                }
                            }
                        }
                    }
                    n.__fresh = true;
                    nodeMap.set(n.id, n);
                    allNodes.push(n);
                }
            }

            for (const l of newLinks) {
                const a = l.source;
                const b = l.target;
                const s = typeof a === 'string' ? a : a.id;
                const t = typeof b === 'string' ? b : b.id;
                const key = s < t ? `${s}|${t}` : `${t}|${s}`;
                if (!linkSet.has(key)) {
                    linkSet.add(key);
                    allLinks.push({ source: s, target: t });
                }
            }
        }

        function getLinkEndId(end) { return typeof end === 'string' ? end : end.id; }

        function computeAdjacency(nodes, links) {
            adjacency.clear();
            for (const n of nodes) adjacency.set(n.id, new Set());
            for (const l of links) {
                const s = getLinkEndId(l.source);
                const t = getLinkEndId(l.target);
                if (!adjacency.has(s)) adjacency.set(s, new Set());
                if (!adjacency.has(t)) adjacency.set(t, new Set());
                adjacency.get(s).add(t);
                adjacency.get(t).add(s);
            }
        }

        function computeDegreeMap(nodes, links) {
            const m = new Map();
            for (const n of nodes) m.set(n.id, 0);
            for (const l of links) {
                m.set(getLinkEndId(l.source), (m.get(getLinkEndId(l.source)) || 0) + 1);
                m.set(getLinkEndId(l.target), (m.get(getLinkEndId(l.target)) || 0) + 1);
            }
            return m;
        }

        // Counts, for each actor, how many CVEs it is associated with in the current dataset
        function computeActorCveCounts(nodes, links) {
            const types = new Map(nodes.map(n => [n.id, n.type]));
            const counts = new Map();
            for (const l of links) {
                const s = getLinkEndId(l.source);
                const t = getLinkEndId(l.target);
                const ts = types.get(s);
                const tt = types.get(t);
                if (ts === 'actor' && tt === 'cve') counts.set(s, (counts.get(s) || 0) + 1);
                if (tt === 'actor' && ts === 'cve') counts.set(t, (counts.get(t) || 0) + 1);
            }
            return counts;
        }

        function updateMinCveSlider(countMap) {
            const slider = document.getElementById('minDegree');
            const label = document.getElementById('minDegreeValue');
            if (!slider) return;
            let max = 0;
            countMap.forEach(v => { if (v > max) max = v; });
            // keep at least 10 for a reasonable range when small graphs
            const newMax = Math.max(10, max);
            if (parseInt(slider.max, 10) !== newMax) {
                slider.max = String(newMax);
            }
            // clamp current value
            if (minDegree > newMax) {
                minDegree = newMax;
                slider.value = String(minDegree);
                if (label) label.textContent = String(minDegree);
            }
        }

        function severityColor(d) {
            const sev = d.details?.severity || 'UNKNOWN';
            switch (sev) {
                case 'LOW': return '#2ca02c';
                case 'MEDIUM': return '#ffbf00';
                case 'HIGH': return '#ff7f0e';
                case 'CRITICAL': return '#d62728';
                default: return '#6baed6';
            }
        }

        function getRadius(d, degreeMap) {
            if (d.type === 'actor') return 10 + Math.min(10, (degreeMap.get(d.id) || 1) * 0.8);
            if (!sizeByDegree) return 8;
            const deg = degreeMap.get(d.id) || 1;
            return 6 + Math.min(12, Math.sqrt(deg) * 3);
        }

        function getLinkDistance(l) {
            const s = getLinkEndId(l.source);
            const t = getLinkEndId(l.target);
            const base = organicMode ? 150 : 90;
            return base + (s.startsWith('CVE-') || t.startsWith('CVE-') ? 30 : 0);
        }

        function loadPersistedPositions() {
            try {
                const raw = localStorage.getItem(POSITION_STORAGE_KEY);
                if (!raw) return new Map();
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return new Map();
                const map = new Map();
                for (const entry of parsed) {
                    if (Array.isArray(entry) && entry.length >= 3) {
                        const [id, x, y] = entry;
                        if (typeof id === 'string' && Number.isFinite(x) && Number.isFinite(y)) {
                            map.set(id, { x, y });
                        }
                    }
                }
                return map;
            } catch (err) {
                console.warn('Failed to load persisted positions', err);
                return new Map();
            }
        }

        function persistNodePositions() {
            try {
                const entries = [];
                for (const node of allNodes) {
                    if (typeof node?.x === 'number' && typeof node?.y === 'number') {
                        entries.push([node.id, Number(node.x.toFixed(1)), Number(node.y.toFixed(1))]);
                        if (entries.length >= MAX_POSITION_STORE) break;
                    }
                }
                localStorage.setItem(POSITION_STORAGE_KEY, JSON.stringify(entries));
                persistedPositions.clear();
                for (const [id, x, y] of entries) {
                    persistedPositions.set(id, { x, y });
                }
            } catch (err) {
                console.warn('Failed to persist positions', err);
            }
        }

        function updateGraphSnapshot(nodes, links) {
            const nodeEl = document.getElementById('statNodes');
            const linkEl = document.getElementById('statLinks');
            const actorEl = document.getElementById('statActors');
            const cveEl = document.getElementById('statCves');
            if (nodeEl) nodeEl.textContent = nodes.length;
            if (linkEl) linkEl.textContent = links.length;
            let actorCount = 0;
            let cveCount = 0;
            const severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
            for (const n of nodes) {
                if (n.type === 'actor') {
                    actorCount++;
                } else if (n.type === 'cve') {
                    cveCount++;
                    const sev = (n.details?.severity || 'UNKNOWN').toUpperCase();
                    if (severityCounts[sev] == null) severityCounts.UNKNOWN += 1;
                    else severityCounts[sev] += 1;
                }
            }
            if (actorEl) actorEl.textContent = actorCount;
            if (cveEl) cveEl.textContent = cveCount;
            const severityMap = {
                CRITICAL: document.getElementById('sevCritical'),
                HIGH: document.getElementById('sevHigh'),
                MEDIUM: document.getElementById('sevMedium'),
                LOW: document.getElementById('sevLow'),
                UNKNOWN: document.getElementById('sevUnknown')
            };
            for (const key of Object.keys(severityMap)) {
                const el = severityMap[key];
                if (el) el.textContent = severityCounts[key] ?? 0;
            }
            if (lastSnapshot) {
                setDelta('statNodesDelta', nodes.length - lastSnapshot.nodes);
                setDelta('statLinksDelta', links.length - lastSnapshot.links);
                setDelta('statActorsDelta', actorCount - lastSnapshot.actors);
                setDelta('statCvesDelta', cveCount - lastSnapshot.cves);
            } else {
                setDelta('statNodesDelta', null);
                setDelta('statLinksDelta', null);
                setDelta('statActorsDelta', null);
                setDelta('statCvesDelta', null);
            }
            lastSnapshot = {
                nodes: nodes.length,
                links: links.length,
                actors: actorCount,
                cves: cveCount,
                severity: severityCounts
            };
        }

        function ensureMiniMapContext() {
            if (!miniMapCanvas) {
                miniMapCanvas = document.getElementById('miniMap');
                if (miniMapCanvas) {
                    miniMapCanvas.style.cursor = 'grab';
                    miniMapCanvas.addEventListener('pointerdown', handleMiniMapPointer);
                }
            }
            if (miniMapCanvas && !miniMapCtx) {
                miniMapCtx = miniMapCanvas.getContext('2d');
            }
        }

        function handleMiniMapPointer(event) {
            if (!miniMapState || !miniMapCanvas || !rootSvg || !zoomBehavior) return;
            const rect = miniMapCanvas.getBoundingClientRect();
            const mx = event.clientX - rect.left;
            const my = event.clientY - rect.top;
            const { minX, minY, scale } = miniMapState;
            const targetX = minX + mx / scale;
            const targetY = minY + my / scale;
            const k = currentTransform.k;
            const newTransform = d3.zoomIdentity.translate(chartWidth / 2, chartHeight / 2).scale(k).translate(-targetX, -targetY);
            miniMapCanvas.setPointerCapture(event.pointerId);
            miniMapCanvas.style.cursor = 'grabbing';
            rootSvg.transition().duration(200).call(zoomBehavior.transform, newTransform);
            const pointerUp = () => {
                miniMapCanvas.style.cursor = 'grab';
                try { miniMapCanvas.releasePointerCapture(event.pointerId); } catch (_) { }
                miniMapCanvas.removeEventListener('pointerup', pointerUp);
                miniMapCanvas.removeEventListener('pointerleave', pointerUp);
            };
            miniMapCanvas.addEventListener('pointerup', pointerUp);
            miniMapCanvas.addEventListener('pointerleave', pointerUp);
        }

        function scheduleMiniMapRender(nodes) {
            ensureMiniMapContext();
            if (!miniMapCtx) return;
            lastMiniMapNodes = Array.isArray(nodes) ? nodes.slice() : [];
            miniMapPayload = lastMiniMapNodes;
            if (!miniMapPending) {
                miniMapPending = true;
                requestAnimationFrame(() => {
                    miniMapPending = false;
                    drawMiniMap();
                });
            }
        }

        function drawMiniMap() {
            ensureMiniMapContext();
            if (!miniMapCtx || !miniMapCanvas) return;
            const ctx = miniMapCtx;
            const canvas = miniMapCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const nodes = Array.isArray(miniMapPayload) ? miniMapPayload : [];
            if (!nodes.length) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const node of nodes) {
                if (typeof node.x === 'number' && typeof node.y === 'number') {
                    if (node.x < minX) minX = node.x;
                    if (node.x > maxX) maxX = node.x;
                    if (node.y < minY) minY = node.y;
                    if (node.y > maxY) maxY = node.y;
                }
            }
            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return;
            const padding = 12;
            const width = Math.max(maxX - minX, 1);
            const height = Math.max(maxY - minY, 1);
            const scale = Math.min((canvas.width - padding * 2) / width, (canvas.height - padding * 2) / height);
            ctx.save();
            ctx.translate(padding, padding);
            for (const node of nodes) {
                if (typeof node.x !== 'number' || typeof node.y !== 'number') continue;
                const x = (node.x - minX) * scale;
                const y = (node.y - minY) * scale;
                ctx.beginPath();
                ctx.fillStyle = node.type === 'actor' ? '#ff5733' : severityColor(node);
                ctx.arc(x, y, node.type === 'actor' ? 3.5 : 3, 0, Math.PI * 2);
                ctx.fill();
            }
            const highlightId = focusMode && focusedNodeId ? focusedNodeId : (insightNode ? insightNode.id : null);
            if (highlightId) {
                const focusNode = nodes.find(n => n.id === highlightId);
                if (focusNode && typeof focusNode.x === 'number' && typeof focusNode.y === 'number') {
                    ctx.beginPath();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = focusMode ? '#0052cc' : '#3290ff';
                    ctx.arc((focusNode.x - minX) * scale, (focusNode.y - minY) * scale, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            if (chartWidth && chartHeight) {
                const viewMinX = -currentTransform.x / currentTransform.k;
                const viewMaxX = (chartWidth - currentTransform.x) / currentTransform.k;
                const viewMinY = -currentTransform.y / currentTransform.k;
                const viewMaxY = (chartHeight - currentTransform.y) / currentTransform.k;
                const rectX = (viewMinX - minX) * scale;
                const rectY = (viewMinY - minY) * scale;
                const rectW = Math.max((viewMaxX - viewMinX) * scale, 8);
                const rectH = Math.max((viewMaxY - viewMinY) * scale, 8);
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 82, 204, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.strokeRect(rectX, rectY, rectW, rectH);
                ctx.restore();
            }
            ctx.restore();
            miniMapState = { minX, minY, scale, width: canvas.width, height: canvas.height };
        }

        function refreshSidebarFocus() {
            let node = null;
            if (focusMode && focusedNodeId) {
                node = nodeMap.get(focusedNodeId);
            } else if (insightNode) {
                node = nodeMap.get(insightNode.id) || insightNode;
            }
            updateInsightPanel(node || null);
        }

        function setInsightNode(node, { persist = true } = {}) {
            if (persist) {
                insightNode = node ? node : null;
            }
            updateInsightPanel(node || (persist ? null : node));
        }

        function updateInsightPanel(node) {
            const title = document.getElementById('focusTitle');
            const meta = document.getElementById('focusMeta');
            const neighborsEl = document.getElementById('focusNeighbors');
            const descEl = document.getElementById('focusDescription');
            const neighborsSection = document.getElementById('focusNeighborsSection');
            if (!title || !meta || !neighborsEl || !descEl) return;
            meta.innerHTML = '';
            neighborsEl.innerHTML = '';
            descEl.textContent = '';
            refreshFocusStyles(node ? node.id : null);
            if (!node) {
                title.textContent = 'No selection yet';
                const li = document.createElement('li');
                li.textContent = 'Hover or select a node to inspect details.';
                neighborsEl.appendChild(li);
                if (neighborsSection) neighborsSection.classList.remove('focus-section-hidden');
                activeFocusTab = 'overview';
                applyFocusTabState();
                return;
            }
            title.textContent = node.name || node.id;
            const appendMeta = (label, value) => {
                const wrapper = document.createElement('div');
                const labelSpan = document.createElement('span');
                labelSpan.textContent = label;
                const valueStrong = document.createElement('strong');
                valueStrong.textContent = value;
                wrapper.appendChild(labelSpan);
                wrapper.appendChild(valueStrong);
                meta.appendChild(wrapper);
            };
            appendMeta('Type', node.type === 'actor' ? 'Actor' : 'CVE');
            const neighborIds = Array.from(adjacency.get(node.id) || []);
            appendMeta(node.type === 'actor' ? 'Linked CVEs' : 'Linked Actors', neighborIds.length.toString());
            if (node.type === 'cve') {
                const severityText = prettifySeverity((node.details?.severity || 'UNKNOWN').toUpperCase());
                appendMeta('Severity', severityText);
                appendMeta('Published', node.details?.dateAdded || 'Unknown');
                const desc = node.details?.shortDescription || 'No description available';
                const trimmed = desc.length > 240 ? `${desc.slice(0, 240)}...` : desc;
                descEl.textContent = trimmed;
            } else {
                const severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
                for (const id of neighborIds) {
                    const neighbor = nodeMap.get(id);
                    if (neighbor && neighbor.details) {
                        const sev = (neighbor.details.severity || 'UNKNOWN').toUpperCase();
                        if (severityCounts[sev] == null) severityCounts.UNKNOWN += 1;
                        else severityCounts[sev] += 1;
                    }
                }
                const summary = SEVERITY_ORDER.filter(level => severityCounts[level] > 0)
                    .map(level => `${severityCounts[level]} ${prettifySeverity(level)}`)
                    .join(', ');
                descEl.textContent = neighborIds.length ? `Exposure mix: ${summary || 'Unknown severities'}.` : 'No linked CVEs currently in view.';
            }
            const neighbors = neighborIds
                .map(id => nodeMap.get(id))
                .filter(Boolean)
                .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
            if (!neighbors.length) {
                const li = document.createElement('li');
                li.textContent = 'No linked nodes in the current view.';
                neighborsEl.appendChild(li);
            } else {
                neighbors.forEach(neighbor => {
                    const li = document.createElement('li');
                    if (node.type === 'actor') {
                        const sev = prettifySeverity((neighbor.details?.severity || 'UNKNOWN').toUpperCase());
                        li.textContent = `${neighbor.name || neighbor.id} (${sev})`;
                    } else {
                        li.textContent = neighbor.name || neighbor.id;
                    }
                    neighborsEl.appendChild(li);
                });
            }
            applyFocusTabState();
        }

        function refreshFocusStyles(activeId) {
            if (!nodeSel) return;
            nodeSel.classed('is-focus', d => d.id === activeId);
            if (labelSel) {
                labelSel.classed('is-focus', d => d.id === activeId);
            }
        }

        function applyFocusTabState() {
            const overview = document.getElementById('focusOverview');
            const neighborsSection = document.getElementById('focusNeighborsSection');
            if (overview) overview.classList.toggle('focus-section-hidden', activeFocusTab !== 'overview');
            if (neighborsSection) neighborsSection.classList.toggle('focus-section-hidden', activeFocusTab !== 'neighbors');
            const tabsContainer = document.getElementById('focusTabs');
            if (tabsContainer) {
                tabsContainer.querySelectorAll('.focus-tab').forEach(btn => {
                    const tab = btn.getAttribute('data-tab');
                    btn.classList.toggle('active', tab === activeFocusTab);
                });
            }
        }

        function setChipState(id, text, { variant = null, hidden = false } = {}) {
            const chip = document.getElementById(id);
            if (!chip) return;
            const label = chip.querySelector('.label-text');
            if (label) label.textContent = text;
            if (hidden) {
                chip.classList.add('hidden');
            } else {
                chip.classList.remove('hidden');
            }
            if (variant) {
                chip.setAttribute('data-variant', variant);
            } else {
                chip.removeAttribute('data-variant');
            }
        }

        function prettifySeverity(value) {
            if (!value || value === 'all') return 'All';
            return value.charAt(0) + value.slice(1).toLowerCase();
        }

        function setDelta(id, delta) {
            const el = document.getElementById(id);
            if (!el) return;
            el.classList.remove('positive', 'negative');
            if (delta == null || delta === 0) {
                el.textContent = '';
                return;
            }
            el.textContent = delta > 0 ? `+${delta}` : `${delta}`;
            el.classList.add(delta > 0 ? 'positive' : 'negative');
        }

        function updateStatusChips() {
            const totalText = pageInfo.total != null ? pageInfo.total : '?';
            const current = pageInfo.current || 0;
            setChipState('chipPage', `Page ${current}/${totalText}`, {
                hidden: current === 0 && pageInfo.total == null
            });

            setChipState('chipLayout', `Layout: ${organicMode ? 'Organic' : 'Structured'}`, {
                variant: organicMode ? 'warning' : null
            });

            const severityText = prettifySeverity(severityFilter);
            let severityVariant = null;
            if (severityFilter === 'CRITICAL') severityVariant = 'danger';
            else if (severityFilter === 'HIGH') severityVariant = 'warning';
            setChipState('chipSeverity', `Severity: ${severityText}`, { variant: severityVariant });

            setChipState('chipMinDegree', `Min CVEs: ${minDegree}`, {
                variant: minDegree > 0 ? 'warning' : null
            });

            const actorLabel = actorDisplayName ? `Actor: ${actorDisplayName}${filterActors ? ' (filtered)' : ''}` : (filterActors ? 'Actor: Filter On' : 'Actor: All');
            setChipState('chipActor', actorLabel, {
                variant: actorDisplayName || filterActors ? 'warning' : null
            });

            setChipState('chipLabels', `Labels: ${labelsOn ? 'On' : 'Off'}`, {
                variant: labelsOn ? null : 'warning'
            });

            let focusText = 'Focus Off';
            let focusVariant = null;
            if (focusMode) {
                focusVariant = 'warning';
                if (focusedNodeId) {
                    const focusName = (nodeMap.get(focusedNodeId) || {}).name || focusedNodeId;
                    focusText = `Focus: ${focusName}`;
                } else {
                    focusText = 'Focus Ready';
                }
            }
            setChipState('chipFocus', focusText, { variant: focusVariant });
            updateSeverityChips();
            updateTips();
        }

        function updateSeverityChips() {
            const container = document.getElementById('severityQuickFilters');
            if (!container) return;
            const buttons = container.querySelectorAll('.severity-chip');
            buttons.forEach(btn => {
                const val = btn.getAttribute('data-severity');
                btn.classList.toggle('active', (severityFilter || 'all') === val);
            });
        }

        function updateTips() {
            const list = document.getElementById('interactionTips');
            if (!list) return;
            list.innerHTML = '';
            const tips = [];
            tips.push('Scroll or pinch to zoom, drag the background to pan.');
            tips.push('Use + / - keys or the toolbar buttons to adjust zoom. Press F to fit, R to reset.');
            if (!focusMode) {
                tips.push('Toggle Focus Mode to isolate a node and its neighborhood.');
            } else if (!focusedNodeId) {
                tips.push('Click any node to lock focus while Focus Mode is enabled.');
            } else {
                tips.push('Use the Exit Focus button or press Esc to leave the focused neighborhood.');
            }
            if (severityFilter !== 'all') {
                tips.push(`Severity filter is set to ${prettifySeverity(severityFilter)}. Click a severity chip to change or show all.`);
            }
            if (minDegree > 0) {
                tips.push(`Min CVEs slider is hiding actors linked to fewer than ${minDegree} CVEs.`);
            }
            for (const tip of tips.slice(0, 5)) {
                const li = document.createElement('li');
                li.textContent = tip;
                list.appendChild(li);
            }
        }

        function bindKeyboardShortcuts() {
            document.addEventListener('keydown', (event) => {
                if (event.defaultPrevented) return;
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
                    return;
                }
                switch (event.key) {
                    case '+':
                    case '=':
                        zoomBy(1.2);
                        event.preventDefault();
                        break;
                    case '-':
                    case '_':
                        zoomBy(1 / 1.2);
                        event.preventDefault();
                        break;
                    case 'f':
                    case 'F':
                        fitToScreen();
                        event.preventDefault();
                        break;
                    case 'r':
                    case 'R':
                        if (rootSvg && zoomBehavior) {
                            rootSvg.transition().duration(250).call(zoomBehavior.transform, d3.zoomIdentity);
                        }
                        event.preventDefault();
                        break;
                    case 'Escape':
                        if (focusMode && focusedNodeId) {
                            focusedNodeId = null;
                            document.getElementById('exitFocus').style.display = 'none';
                            visualizeData({ nodes: allNodes, links: allLinks });
                            updateStatusChips();
                            refreshSidebarFocus();
                        }
                        break;
                    default:
                        break;
                }
            });
        }

        // Status + progress
        function setStatus(text) { document.getElementById('statusText').textContent = text; }
        function updateCounts() { document.getElementById('countsText').textContent = `Nodes: ${allNodes.length}, Links: ${allLinks.length}`; }
        function showProgress() { document.getElementById('progressContainer').style.display = 'block'; }
        function hideProgress() { document.getElementById('progressContainer').style.display = 'none'; }
        function resetProgress() { updateProgress(0, 1); hideProgress(); }
        function updateProgress(page, total) {
            const pct = Math.max(0, Math.min(100, Math.round((page / total) * 100)));
            const bar = document.getElementById('loadProgress');
            bar.style.width = pct + '%';
            bar.textContent = pct + '%';
            bar.setAttribute('aria-valuenow', pct.toString());
        }

        // Zoom helpers
        function zoomBy(k) {
            if (!rootSvg || !zoomBehavior) return;
            rootSvg.transition().duration(200).call(zoomBehavior.scaleBy, k);
        }
        function fitToScreen() {
            if (!rootSvg || !zoomGroup || !zoomBehavior) return;
            const bounds = zoomGroup.node().getBBox();
            const parent = rootSvg.node().getBoundingClientRect();
            const fullWidth = parent.width, fullHeight = parent.height;
            const width = bounds.width, height = bounds.height;
            const midX = bounds.x + width / 2, midY = bounds.y + height / 2;
            if (!width || !height) return; // no content
            const scale = 0.9 / Math.max(width / fullWidth, height / fullHeight);
            const transform = d3.zoomIdentity.translate(fullWidth / 2, fullHeight / 2).scale(scale).translate(-midX, -midY);
            rootSvg.transition().duration(400).call(zoomBehavior.transform, transform);
        }

        // Export SVG
        function exportSVG() {
            if (!rootSvg) return;
            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(rootSvg.node());
            const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'kev_graph.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function applyForces(degreeMap, width, height) {
            if (!simulation) return;
            const linkForce = simulation.force('link');
            if (linkForce && linkForce.distance) linkForce.distance(d => getLinkDistance(d)).strength(organicMode ? 0.5 : 0.6);
            const chargeForce = simulation.force('charge');
            if (chargeForce && chargeForce.strength) chargeForce.strength(organicMode ? -220 : -120);
            const collForce = simulation.force('collision');
            if (collForce && collForce.radius) collForce.radius(d => getRadius(d, degreeMap) + (organicMode ? 2 : 6));
            if (organicMode) {
                simulation.force('x', null);
            } else {
                simulation.force('x', d3.forceX(d => d.type === 'actor' ? width * 0.3 : width * 0.7).strength(0.05));
            }
            simulation.alpha(0.7).restart();
        }

        // Focus by node id (best-effort)
        function focusOnNodeById(id) {
            const match = allNodes.find(n => n.id === id);
            if (!match || !rootSvg || !zoomBehavior || !zoomGroup) return;
            // approximate center on latest layout
            const cx = match.x || 0, cy = match.y || 0;
            const parent = rootSvg.node().getBoundingClientRect();
            const transform = d3.zoomIdentity.translate(parent.width / 2, parent.height / 2).scale(1.5).translate(-cx, -cy);
            rootSvg.transition().duration(300).call(zoomBehavior.transform, transform);
        }

        // Initialize from URL params if present
        (function initFromQuery() {
            try {
                const params = new URLSearchParams(window.location.search);
                const actor = params.get('actor');
                const p = parseInt(params.get('per_page') || '0', 10);
                if (p) { perPage = Math.max(1, Math.min(100, p)); document.getElementById('perPage').value = perPage; }
                if (actor) {
                    document.getElementById('actorSearch').value = actor;
                    actorDisplayName = actor;
                    searchedActor = actor.toLowerCase();
                    updateStatusChips();
                    fetchDataByActor(searchedActor);
                }
            } catch { /* ignore */ }
        })();

        updateGraphSnapshot([], []);
        scheduleMiniMapRender([]);
        updateStatusChips();
        window.addEventListener('beforeunload', persistNodePositions);
        refreshSidebarFocus();
        bindKeyboardShortcuts();

    </script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>
        
