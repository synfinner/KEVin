<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE Visualization</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!-- Font Awesome for icons -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            /* Light theme */
            transition: background-color 0.3s, color 0.3s;
        }

        body.bg-dark {
            background: linear-gradient(to right, #1a1a1a, #333);
            /* Dark theme */
            color: #E0E0E0;
            /* Light text color for dark theme */
        }

        #chart {
            width: 100%;
            height: 800px;
            /* Increased height from 600px to 800px */
            margin: 20px auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background-color: #fff;
            /* Light background for chart */
            position: relative;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            /* Added shadow for depth */
            max-width: 1200px;
            /* Set a maximum width for the chart */
        }

        body.bg-dark #chart {
            background-color: #2C2C2C;
            /* Dark background for chart */
            border-color: #444;
            /* Darker border for dark theme */
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            padding: 8px;
            font: 12px sans-serif;
            background: lightsteelblue;
            /* Light tooltip background */
            border: 0;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        body.bg-dark .tooltip {
            background: #444;
            /* Dark tooltip background */
            color: #E0E0E0;
            /* Light text color for tooltip */
        }

        .node {
            stroke: #fff;
            /* Node stroke color */
            stroke-width: 1.5px;
            transition: transform 0.2s;
            /* Smooth transition for node movement */
        }

        body.bg-dark .node {
            stroke: #444;
            /* Darker stroke for nodes in dark theme */
        }

        .link {
            stroke: #999;
            /* Link color */
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s;
            /* Smooth transition for link opacity */
        }

        body.bg-dark .link {
            stroke: #666;
            /* Darker link color for dark theme */
        }

        .label {
            font-size: 12px;
            pointer-events: none;
            color: #000;
            /* Label color */
        }

        body.bg-dark .label {
            color: #E0E0E0;
            /* Light label color for dark theme */
        }

        .info-box {
            position: absolute;
            width: 300px;
            background: #fff;
            /* Light info box background */
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        body.bg-dark .info-box {
            background: #2C2C2C;
            /* Dark info box background */
            border-color: #444;
            /* Darker border for info box */
            color: #E0E0E0;
            /* Light text color for info box */
        }

        .info-box h5 {
            margin-top: 0;
        }

        .controls {
            text-align: center;
            margin-bottom: 10px;
        }

        .controls button {
            margin: 5px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .custom-switch {
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <div class="container mt-5">
        <div class="header">
            <h1 class="display-4">CISA KEV CVE Graph by Threat Actors</h1>
            <p class="lead">Explore vulnerabilities and their associated threat actors.</p>
        </div>
        <div class="controls">
            <button class="btn btn-primary" id="fetchData"><i class="fas fa-download"></i> Fetch Data</button>
            <button class="btn btn-secondary" id="loadMoreData"><i class="fas fa-plus"></i> Load More Data</button>
            <button class="btn btn-danger" id="resetView"><i class="fas fa-redo"></i> Reset View</button>
            <input type="text" id="actorSearch" placeholder="Search by Actor" class="form-control d-inline"
                style="width: 200px;">
            <button class="btn btn-success" id="searchByActor"><i class="fas fa-search"></i> Search</button>
            <button class="btn btn-warning" id="cancelSearch" style="display: none;">Cancel Search</button>
            <!-- Cancel button -->
            <div class="custom-control custom-switch">
                <input type="checkbox" class="custom-control-input" id="darkThemeToggle">
                <label class="custom-control-label" for="darkThemeToggle">Dark Theme</label>
            </div>
        </div>
        <div id="chart"></div>
        <div class="info-box" id="infoBox"></div>
    </div>

    <script>
        let simulation;
        let currentPage = 1;
        let allNodes = [];
        let allLinks = [];
        let abortController = null;

        document.getElementById('fetchData').addEventListener('click', function () {
            fetchData(currentPage);
        });

        document.getElementById('loadMoreData').addEventListener('click', function () {
            currentPage++;
            fetchData(currentPage);
        });

        document.getElementById('resetView').addEventListener('click', function () {
            d3.select("#chart").selectAll("*").remove();
            allNodes = [];
            allLinks = [];
            currentPage = 1;
        });

        document.getElementById('searchByActor').addEventListener('click', function () {
            cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
            const actor = document.getElementById('actorSearch').value;
            fetchDataByActor(actor);
        });

        document.getElementById('cancelSearch').addEventListener('click', function () {
            cancelCurrentRequest(); // Cancel any ongoing request
        });

        document.getElementById('actorSearch').addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
                const actor = document.getElementById('actorSearch').value;
                fetchDataByActor(actor);
            }
        });

        function cancelCurrentRequest() {
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
        }

        function fetchData(page) {
            cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
            abortController = new AbortController();
            const signal = abortController.signal;

            fetch(`/kev?page=${page}&per_page=25`, { signal })
                .then(response => response.json())
                .then(data => {
                    if (abortController.signal.aborted) return; // Check if the request was aborted
                    const formattedData = formatData(data.vulnerabilities);
                    allNodes = allNodes.concat(formattedData.nodes);
                    allLinks = allLinks.concat(formattedData.links);
                    visualizeData({ nodes: allNodes, links: allLinks });
                })
                .catch(error => {
                    if (error.name === 'AbortError') {
                        console.log('Fetch request canceled');
                    } else {
                        console.error('Error fetching data:', error);
                    }
                });
        }

        function fetchDataByActor(actor) {
            cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
            abortController = new AbortController();
            const signal = abortController.signal;

            fetch(`/kev?actor=${actor}&page=${currentPage}&per_page=25`, { signal })
                .then(response => response.json())
                .then(data => {
                    if (abortController.signal.aborted) return; // Check if the request was aborted
                    const formattedData = formatData(data.vulnerabilities);
                    allNodes = allNodes.concat(formattedData.nodes);
                    allLinks = allLinks.concat(formattedData.links);
                    visualizeData({ nodes: allNodes, links: allLinks });

                    // Show cancel button
                    document.getElementById('cancelSearch').style.display = 'inline-block';

                    // Automatically load subsequent pages if total_pages > 1
                    if (data.total_pages > 1) {
                        loadMoreDataByActor(actor, data.total_pages);
                    }
                })
                .catch(error => {
                    if (error.name === 'AbortError') {
                        console.log('Fetch request canceled');
                    } else {
                        console.error('Error fetching data:', error);
                    }
                });
        }

        function loadMoreDataByActor(actor, totalPages) {
            let page = 2;

            const fetchPage = () => {
                if (page > totalPages) return; // End recursion

                cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
                abortController = new AbortController();
                const signal = abortController.signal;

                fetch(`/kev?actor=${actor}&page=${page}&per_page=25`, { signal })
                    .then(response => response.json())
                    .then(data => {
                        if (abortController.signal.aborted) return; // Check if the request was aborted
                        const formattedData = formatData(data.vulnerabilities);
                        allNodes = allNodes.concat(formattedData.nodes);
                        allLinks = allLinks.concat(formattedData.links);
                        visualizeData({ nodes: allNodes, links: allLinks });
                        page++;
                        setTimeout(fetchPage, 2000); // Wait 1.5 seconds before fetching next page
                    })
                    .catch(error => {
                        if (error.name === 'AbortError') {
                            console.log('Fetch request canceled');
                        } else {
                            console.error('Error fetching data:', error);
                        }
                    });
            };

            fetchPage(); // Start fetching pages
        }

        function formatData(vulnerabilities) {
            const nodes = [];
            const links = [];
            const actorMap = new Map();

            vulnerabilities.forEach(vuln => {
                const threatData = vuln.openThreatData[0];
                const adversaries = threatData.adversaries || [];
                const communityAdversaries = threatData.communityAdversaries || [];
                const uniqueAdversaries = new Set([...adversaries, ...communityAdversaries]);

                if (uniqueAdversaries.size > 0) {
                    const cveNode = { id: vuln.cveID, name: vuln.cveID, type: 'cve', details: vuln };
                    nodes.push(cveNode);

                    uniqueAdversaries.forEach(actor => {
                        const actorNode = { id: actor, name: actor, type: 'actor' };
                        if (!actorMap.has(actor)) {
                            actorMap.set(actor, actorNode);
                            nodes.push(actorNode);
                        }
                        links.push({ source: cveNode.id, target: actor });
                    });
                }
            });

            return { nodes, links };
        }

        function visualizeData(data) {
            d3.select("#chart").selectAll("*").remove();

            const width = document.getElementById('chart').clientWidth;
            const height = document.getElementById('chart').clientHeight;

            const svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .call(d3.zoom().on("zoom", (event) => {
                    svg.attr("transform", event.transform);
                }))
                .append("g")
                .attr("transform", "scale(0.8)");

            const tooltip = d3.select("#chart")
                .append("div")
                .attr("class", "tooltip");

            const infoBox = d3.select("#infoBox");

            simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink().id(d => d.id).distance(100).strength(0.5))
                .force("charge", d3.forceManyBody().strength(-50))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(20).strength(0));

            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(data.links)
                .enter().append("line")
                .attr("class", "link")
                .attr("stroke-width", 2)
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6);

            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(data.nodes)
                .enter().append("circle")
                .attr("class", "node")
                .attr("r", 8)
                .attr("fill", d => d.type === 'actor' ? '#ff5733' : '#007bff')
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", mouseover)
                .on("mouseout", mouseout)
                .on("click", function (event, d) {
                    if (d.type === 'cve') {
                        infoBox.style("display", "block")
                            .html(`
                        <h5>${d.details.vulnerabilityName}</h5>
                        <p><strong>CVE ID:</strong> ${d.details.cveID}</p>
                        <p><strong>Severity:</strong> ${d.details.nvdData[0]?.baseSeverity || 'Unknown'}</p>
                        <p><strong>Published Date:</strong> ${d.details.dateAdded}</p>
                        <div>
                            <strong>GitHub PoCs:</strong>
                            <div class="github-pocs">
                                ${d.details.githubPocs && d.details.githubPocs.length > 0 ? 'GitHub PoCs available' : 'No GitHub PoCs'}
                            </div>
                        </div>
                    `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px")
                            .transition().duration(200)
                            .style("opacity", .9);
                        event.stopPropagation();
                    }
                });

            const label = svg.append("g")
                .attr("class", "labels")
                .selectAll("text")
                .data(data.nodes)
                .enter().append("text")
                .attr("class", "label")
                .attr("dx", 12)
                .attr("dy", ".35em")
                .text(d => d.name)
                .style("fill", d => body.classList.contains('bg-dark') ? '#E0E0E0' : '#000');

            simulation
                .nodes(data.nodes)
                .on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);

                    label
                        .attr("x", d => d.x)
                        .attr("y", d => d.y);
                });

            simulation.force("link")
                .links(data.links);

            d3.select("body").on("click", function (event) {
                const isOutside = !event.target.closest("#chart") && !event.target.closest(".tooltip") && !event.target.closest(".info-box");
                if (isOutside) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                    infoBox.transition()
                        .duration(500)
                        .style("opacity", 0);
                } else if (!event.target.closest(".github-pocs a")) {
                    infoBox.transition()
                        .duration(500)
                        .style("opacity", 0);
                }
            });

            function mouseover(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html(d.name)
                    .style("left", (event.pageX + 5) + "px")
                    .style("top", (event.pageY - 28) + "px");
            }

            function mouseout(event, d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        const darkThemeToggle = document.getElementById('darkThemeToggle');
        const body = document.body;

        const userThemePreference = localStorage.getItem('darkTheme');
        if (userThemePreference === 'true') {
            body.classList.add('bg-dark');
            body.classList.add('text-light');
            darkThemeToggle.checked = true;
        }

        darkThemeToggle.addEventListener('change', () => {
            if (darkThemeToggle.checked) {
                body.classList.add('bg-dark');
                body.classList.add('text-light');
                localStorage.setItem('darkTheme', 'true');
            } else {
                body.classList.remove('bg-dark');
                body.classList.remove('text-light');
                localStorage.setItem('darkTheme', 'false');
            }
        });

    </script>
</body>

</html>
