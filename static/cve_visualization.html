<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE Visualization</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!-- Font Awesome for icons -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Layout */
        .navbar-brand {
            font-weight: 700;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(to right, #f8f9fa, #e9ecef);
            transition: background-color 0.3s, color 0.3s;
            color: #333;
        }

        body.bg-dark {
            background: linear-gradient(to right, #1a1a1a, #333);
            color: #E0E0E0;
        }

        #chart {
            width: 100%;
            height: 800px;
            margin: 20px auto;
            border: none;
            border-radius: 15px;
            background-color: #fff;
            position: relative;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            max-width: 1600px;
            overflow: hidden;
        }

        body.bg-dark #chart {
            background-color: #2C2C2C;
            border-color: #444;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: auto;
            padding: 10px;
            font: 14px sans-serif;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        body.bg-dark .tooltip {
            background: rgba(68, 68, 68, 0.95);
            color: #E0E0E0;
        }

        .node {
            stroke: #fff;
            stroke-width: 1.5px;
            transition: transform 0.2s;
        }

        body.bg-dark .node {
            stroke: #444;
        }

        .node.has-poc {
            filter: drop-shadow(0 0 8px rgba(220, 53, 69, 0.6));
            animation: pocHalo 2.2s ease-in-out infinite;
        }

        body.bg-dark .node.has-poc {
            filter: drop-shadow(0 0 9px rgba(255, 115, 155, 0.65));
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s;
        }

        body.bg-dark .link {
            stroke: #666;
        }

        .label {
            font-size: 14px;
            pointer-events: none;
            color: #000;
            /* Improve readability with a light stroke halo */
            paint-order: stroke fill;
            stroke: rgba(255, 255, 255, 0.85);
            stroke-width: 3px;
        }

        body.bg-dark .label {
            color: #E0E0E0;
            stroke: rgba(0, 0, 0, 0.85);
        }

        .node.is-search-match {
            stroke: #ff9800;
            stroke-width: 3px;
        }

        body.bg-dark .node.is-search-match {
            stroke: #ffd166;
        }

        .label.is-search-match {
            font-weight: 600;
        }

        .node.dimmed {
            opacity: 0.18;
            filter: blur(1.6px);
        }

        body.bg-dark .node.dimmed {
            opacity: 0.12;
        }

        .label.dimmed {
            opacity: 0.18;
            filter: blur(1px);
        }

        .link.dimmed {
            opacity: 0.05;
        }

        .node.search-dimmed {
            opacity: 0.2;
            filter: blur(1.4px);
        }

        body.bg-dark .node.search-dimmed {
            opacity: 0.14;
        }

        .label.search-dimmed {
            opacity: 0.2;
            filter: blur(1px);
        }

        .node.search-hidden,
        .label.search-hidden,
        .link.search-hidden {
            display: none;
        }

        .info-box {
            position: absolute;
            width: 350px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            font-size: 14px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1001;
        }

        body.bg-dark .info-box {
            background: #2C2C2C;
            border-color: #444;
            color: #E0E0E0;
        }

        .info-box h5 {
            margin-top: 0;
        }

        .hero-panel {
            max-width: 1200px;
            margin: 0 auto 32px;
            padding: 36px 42px 30px;
            border-radius: 40px;
            background: linear-gradient(140deg, rgba(255, 255, 255, 0.92), rgba(235, 240, 255, 0.88));
            box-shadow: 0 22px 60px rgba(15, 40, 80, 0.15);
            position: relative;
        }

        body.bg-dark .hero-panel {
            background: linear-gradient(140deg, rgba(38, 41, 55, 0.92), rgba(24, 24, 24, 0.95));
            box-shadow: 0 26px 70px rgba(0, 0, 0, 0.6);
        }

        .hero-panel::after {
            content: '';
            position: absolute;
            inset: 12px;
            border-radius: 32px;
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0));
            pointer-events: none;
            z-index: 0;
        }

        body.bg-dark .hero-panel::after {
            background: linear-gradient(120deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0));
        }

        .hero-panel > * {
            position: relative;
            z-index: 1;
        }

        .control-stack {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-top: 24px;
        }

        .control-row {
            background: rgba(255, 255, 255, 0.72);
            border-radius: 28px;
            padding: 14px 24px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65), 0 10px 25px rgba(15, 40, 80, 0.08);
        }

        body.bg-dark .control-row {
            background: rgba(40, 42, 50, 0.85);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 14px 28px rgba(0, 0, 0, 0.35);
        }

        .control-row.secondary {
            padding: 18px 24px;
        }

        .control-row.secondary .custom-control {
            margin-bottom: 0;
        }

        .control-row.secondary .custom-control-label {
            font-size: 0.95rem;
        }

        .graph-surface {
            display: flex;
            gap: 24px;
            align-items: stretch;
        }

        .graph-main {
            position: relative;
            flex: 1 1 auto;
            min-height: 820px;
        }

        .graph-sidebar {
            width: 310px;
            background: rgba(255, 255, 255, 0.78);
            border-radius: 28px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 14px 35px rgba(15, 40, 80, 0.08);
            padding: 20px 22px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        body.bg-dark .graph-sidebar {
            background: rgba(38, 40, 50, 0.9);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 16px 40px rgba(0, 0, 0, 0.5);
        }

        .sidebar-section {
            background: rgba(255, 255, 255, 0.65);
            border-radius: 20px;
            padding: 16px 18px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        body.bg-dark .sidebar-section {
            background: rgba(28, 30, 40, 0.72);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .sidebar-section h5 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .focus-title {
            font-size: 1.05rem;
            font-weight: 600;
        }

        .focus-tabs {
            display: inline-flex;
            border-radius: 18px;
            padding: 4px;
            background: rgba(0,0,0,0.05);
            margin-top: 10px;
            margin-bottom: 12px;
        }

        body.bg-dark .focus-tabs {
            background: rgba(255, 255, 255, 0.08);
        }

        .focus-tab {
            border: none;
            background: transparent;
            font-size: 0.82rem;
            padding: 6px 14px;
            border-radius: 14px;
            cursor: pointer;
            color: #4f5d78;
        }

        .focus-tab.active {
            background: #0052cc;
            color: #fff;
            box-shadow: 0 4px 14px rgba(0, 82, 204, 0.2);
        }

        body.bg-dark .focus-tab {
            color: #cbd7ff;
        }

        body.bg-dark .focus-tab.active {
            background: #82a7ff;
            color: #0d1c3f;
        }

        .focus-neighbors-wrapper {
            max-height: 220px;
            overflow: hidden;
        }

        .focus-section-hidden {
            display: none;
        }

        .focus-meta {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px 12px;
            font-size: 0.9rem;
        }

        .focus-meta span {
            display: block;
            color: #4f5d78;
        }

        .focus-meta strong {
            display: block;
            font-weight: 600;
            color: #1d2f4a;
        }

        body.bg-dark .focus-meta span {
            color: #cbd7ff;
        }

        body.bg-dark .focus-meta strong {
            color: #fff;
        }

        .focus-neighbors {
            margin: 12px 0 0;
            padding-left: 18px;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .focus-neighbors li {
            margin-bottom: 4px;
        }

        .focus-description {
            margin-top: 12px;
            font-size: 0.86rem;
            line-height: 1.4;
        }

        body.bg-dark .focus-description {
            color: #dfe6ff;
        }

        .focus-pocs {
            margin-top: 12px;
            font-size: 0.82rem;
            line-height: 1.4;
            max-height: 160px;
            overflow-y: auto;
            padding-right: 6px;
        }

        .focus-pocs-title {
            font-weight: 600;
            margin-bottom: 6px;
        }

        .focus-pocs-list {
            list-style: none;
            padding-left: 0;
            margin-bottom: 0;
        }

        .focus-pocs-list li {
            margin-bottom: 6px;
        }

        .focus-pocs a {
            word-break: break-all;
        }

        body.bg-dark .focus-pocs a {
            color: #a9c4ff;
        }

        .quick-filters {
            margin-top: 14px;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }

        .severity-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.82rem;
            padding: 6px 10px;
            border-radius: 18px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 0.85);
            box-shadow: 0 4px 12px rgba(15, 40, 80, 0.05);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .severity-chip.active {
            border-color: #0052cc;
            box-shadow: 0 6px 18px rgba(0, 82, 204, 0.18);
        }

        body.bg-dark .severity-chip {
            background: rgba(34, 36, 45, 0.9);
            border-color: rgba(255, 255, 255, 0.12);
            color: #e1e7ff;
        }

        body.bg-dark .severity-chip.active {
            border-color: #82a7ff;
            box-shadow: 0 6px 18px rgba(130, 167, 255, 0.28);
        }

        .severity-chip .dot {
            width: 9px;
            height: 9px;
            border-radius: 50%;
        }

        .delta {
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: auto;
            color: #6c7a99;
        }

        .delta.positive {
            color: #1c7c33;
        }

        .delta.negative {
            color: #b32d2d;
        }

        body.bg-dark .delta {
            color: #c3ccf6;
        }

        .snapshot-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.88rem;
            margin-bottom: 6px;
            align-items: center;
        }

        .snapshot-row strong {
            font-weight: 600;
        }

        .severity-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .snapshot-row.severity-pill {
            justify-content: flex-start;
            gap: 10px;
        }

        .snapshot-row.severity-pill strong {
            min-width: 28px;
        }

        .severity-pill .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .mini-map-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        #miniMap {
            width: 100%;
            border-radius: 16px;
            background: rgba(255, 255, 255, 0.85);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.08);
        }

        body.bg-dark #miniMap {
            background: rgba(20, 22, 30, 0.9);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.4);
        }

        .mini-map-hint {
            font-size: 0.8rem;
            color: #6c7a99;
            text-align: center;
        }

        body.bg-dark .mini-map-hint {
            color: #c3ccf6;
        }

        @keyframes nodePulse {
            0% { stroke-width: 6px; stroke-opacity: 0.85; }
            100% { stroke-width: 1.5px; stroke-opacity: 0.2; }
        }

        .node.new-node {
            stroke: rgba(0, 82, 204, 0.7);
            animation: nodePulse 1.1s ease-out;
        }

        .node.is-focus {
            stroke: #0052cc;
            stroke-width: 3px;
        }

        body.bg-dark .node.is-focus {
            stroke: #82a7ff;
        }

        .label.is-focus {
            font-weight: 700;
        }

        @keyframes pocHalo {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 0;
            width: 100%;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }

        :root {
            --control-height: 48px;
            --control-radius: 28px;
        }

        .controls .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            font-size: 16px;
            padding: 0 24px;
            height: var(--control-height);
            border-radius: var(--control-radius);
            border: none;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .controls .btn:focus,
        .controls .btn:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.18);
            transform: translateY(-1px);
        }

        .controls .input-group {
            height: var(--control-height);
            border-radius: var(--control-radius);
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        .controls .input-group .input-group-prepend .input-group-text,
        .controls .input-group .input-group-append .input-group-text {
            height: 100%;
            display: flex;
            align-items: center;
            padding: 0 16px;
            border: none;
            background: rgba(0, 0, 0, 0.05);
        }

        body.bg-dark .controls .input-group .input-group-prepend .input-group-text,
        body.bg-dark .controls .input-group .input-group-append .input-group-text {
            background: rgba(255, 255, 255, 0.08);
            color: #dce4ff;
        }

        body.bg-dark .controls .input-group .input-group-prepend .input-group-text,
        body.bg-dark .controls .input-group .input-group-append .input-group-text {
            background: rgba(255, 255, 255, 0.08);
            color: #dce4ff;
        }

        .controls .input-group .form-control,
        .controls .input-group select,
        .controls .input-group input[type="number"],
        .controls .input-group input[type="text"] {
            height: 100%;
            border: none;
            padding: 0 16px;
            font-size: 16px;
            box-shadow: none;
        }

        body.bg-dark .controls .input-group .form-control,
        body.bg-dark .controls .input-group select,
        body.bg-dark .controls .input-group input[type="number"],
        body.bg-dark .controls .input-group input[type="text"] {
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        body.bg-dark .controls .input-group .form-control,
        body.bg-dark .controls .input-group select,
        body.bg-dark .controls .input-group input[type="number"],
        body.bg-dark .controls .input-group input[type="text"] {
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        .controls .form-control,
        .controls select,
        .controls input[type="number"],
        .controls input[type="text"] {
            height: var(--control-height);
            border-radius: var(--control-radius);
            border: 1px solid #ccc;
            font-size: 16px;
            padding: 0 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        body.bg-dark .controls .form-control,
        body.bg-dark .controls select,
        body.bg-dark .controls input[type="number"],
        body.bg-dark .controls input[type="text"] {
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        body.bg-dark .controls .form-control,
        body.bg-dark .controls select,
        body.bg-dark .controls input[type="number"],
        body.bg-dark .controls input[type="text"] {
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(34, 36, 45, 0.95);
            color: #f0f4ff;
        }

        .controls .form-control:focus,
        .controls select:focus,
        .controls input[type="number"]:focus,
        .controls input[type="text"]:focus {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        body.bg-dark .controls .form-control:focus,
        body.bg-dark .controls select:focus,
        body.bg-dark .controls input[type="number"]:focus,
        body.bg-dark .controls input[type="text"]:focus {
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.45);
        }

        body.bg-dark .controls .form-control:focus,
        body.bg-dark .controls select:focus,
        body.bg-dark .controls input[type="number"]:focus,
        body.bg-dark .controls input[type="text"]:focus {
            box-shadow: 0 6px 22px rgba(0, 0, 0, 0.45);
        }

        .status-chip-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 12px 0 4px;
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 999px;
            background: rgba(0, 82, 204, 0.08);
            color: #1d3a6b;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.01em;
            text-transform: uppercase;
        }

        .status-chip.hidden {
            display: none;
        }

        body.bg-dark .status-chip {
            background: rgba(132, 170, 255, 0.18);
            color: #d6e2ff;
        }

        .status-chip[data-variant="warning"] {
            background: rgba(255, 193, 7, 0.15);
            color: #7a5400;
        }

        body.bg-dark .status-chip[data-variant="warning"] {
            background: rgba(255, 193, 7, 0.25);
            color: #ffd267;
        }

        .status-chip[data-variant="danger"] {
            background: rgba(220, 53, 69, 0.15);
            color: #7a1120;
        }

        body.bg-dark .status-chip[data-variant="danger"] {
            background: rgba(220, 53, 69, 0.3);
            color: #ff9aa8;
        }

        .status-chip .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.6;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: #333;
        }

        .header p {
            font-size: 1.2rem;
            color: #666;
        }

        body.bg-dark .header h1 {
            color: #E0E0E0;
        }

        body.bg-dark .header p {
            color: #AAA;
        }

        .custom-switch {
            margin-top: 0;
        }

        .loading-spinner {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
        }


        .status-bar {
            margin-top: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            background: rgba(255, 255, 255, 0.78);
            padding: 14px 20px;
            border-radius: 20px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 8px 24px rgba(15, 40, 80, 0.08);
        }

        body.bg-dark .status-bar {
            background: rgba(40, 42, 50, 0.88);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04), 0 12px 28px rgba(0, 0, 0, 0.4);
        }

        .status-bar .text-muted {
            color: #2f3d55 !important;
        }

        body.bg-dark .status-bar .text-muted {
            color: #d0d7f5 !important;
        }

        .progress {
            height: 10px;
            background-color: rgba(0, 0, 0, 0.08);
            border-radius: 6px;
        }

        body.bg-dark .progress {
            background-color: rgba(255, 255, 255, 0.12);
        }
        .btn-icon {
            padding: 6px 10px;
        }
        body.bg-dark .btn-outline-dark {
            color: #f5f8ff;
            border-color: rgba(255, 255, 255, 0.25);
        }

        body.bg-dark .btn-outline-dark:hover,
        body.bg-dark .btn-outline-dark:focus {
            background: rgba(255, 255, 255, 0.12);
            color: #f5f8ff;
        }
        .floating-right {
            position: absolute;
            bottom: 12px;
            right: 12px;
            display: flex;
            gap: 8px;
            z-index: 1000;
        }

        @media (max-width: 992px) {
            .hero-panel {
                padding: 28px 30px 26px;
                border-radius: 32px;
            }
            :root {
                --control-height: 46px;
            }
            .control-group {
                justify-content: center;
            }
            .control-row {
                padding: 16px 18px;
            }
            .status-chip-row {
                gap: 8px;
            }
            .graph-surface {
                flex-direction: column;
            }
            .graph-sidebar {
                width: 100%;
            }
        }

        @media (max-width: 576px) {
            .hero-panel {
                padding: 24px 18px 22px;
            }
            :root {
                --control-height: 44px;
                --control-radius: 22px;
            }
            .controls .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            .controls .btn,
            .controls .input-group,
            .controls .form-control,
            .controls select,
            .controls input[type="number"],
            .controls input[type="text"] {
                width: 100% !important;
            }
            .status-chip-row {
                justify-content: flex-start;
            }
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
            .floating-right {
                right: 6px;
            }
            .quick-filters {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }
    </style>
</head>

<body>
    <!-- Top Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <a class="navbar-brand" href="/">KEVin</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active"><a class="nav-link" href="/graph">Graph</a></li>
                <li class="nav-item"><a class="nav-link" href="/viz">Viz</a></li>
                <li class="nav-item"><a class="nav-link" href="/rss">RSS</a></li>
                <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
            </ul>
            <div class="form-inline my-2 my-lg-0">
                <input id="globalSearch" class="form-control mr-sm-2" type="search" placeholder="Search CVE or Actor" aria-label="Search" style="width: 240px;">
                <button id="globalSearchBtn" class="btn btn-outline-success my-2 my-sm-0" type="button"><i class="fas fa-search"></i></button>
            </div>
        </div>
    </nav>

    <div class="container mt-5">
        <div class="hero-panel">
            <div class="header">
                <h1 class="display-4">CISA KEV CVE Graph by Threat Actors</h1>
                <p class="lead">Explore vulnerabilities and their associated threat actors.</p>
            </div>

            <div class="control-stack">
                <div class="control-row primary">
                    <div class="controls">
                        <div class="control-group">
                            <button class="btn btn-primary" id="fetchData"><i class="fas fa-download"></i> Fetch</button>
                            <button class="btn btn-secondary" id="loadMoreData"><i class="fas fa-plus"></i> More</button>
                            <button class="btn btn-info" id="loadAll"><i class="fas fa-list"></i> Load All</button>
                            <button class="btn btn-info" id="layoutToggle"><i class="fas fa-project-diagram"></i> Organic</button>
                            <button class="btn btn-danger" id="resetView"><i class="fas fa-redo"></i> Reset</button>
                            <div class="input-group" style="width: 220px;">
                                <div class="input-group-prepend"><span class="input-group-text">per_page</span></div>
                                <input type="number" id="perPage" class="form-control" min="1" max="100" value="25">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="control-row secondary">
                    <div class="controls">
                        <div class="control-group">
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="darkThemeToggle">
                                <label class="custom-control-label" for="darkThemeToggle">Dark Theme</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="filterActorsToggle">
                                <label class="custom-control-label" for="filterActorsToggle">Filter Actors</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="labelsToggle" checked>
                                <label class="custom-control-label" for="labelsToggle">Labels</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="sizeByDegreeToggle" checked>
                                <label class="custom-control-label" for="sizeByDegreeToggle">Size by Degree</label>
                            </div>
                            <div class="custom-control custom-switch">
                                <input type="checkbox" class="custom-control-input" id="focusModeToggle">
                                <label class="custom-control-label" for="focusModeToggle">Focus Mode</label>
                            </div>
                            <div class="input-group" style="width: 320px;">
                                <div class="input-group-prepend"><span class="input-group-text">Actor</span></div>
                                <input type="text" id="actorSearch" placeholder="Search by Actor" class="form-control">
                                <div class="input-group-append">
                                    <button class="btn btn-success" id="searchByActor" title="Search"><i class="fas fa-search"></i></button>
                                    <button class="btn btn-outline-secondary" id="clearActorSearch" title="Clear"><i class="fas fa-times"></i></button>
                                </div>
                            </div>
                            <button class="btn btn-warning" id="cancelSearch" style="display: none;">Cancel</button>
                            <div class="input-group" style="width: 280px;">
                                <div class="input-group-prepend"><span class="input-group-text">Severity</span></div>
                                <select id="severityFilter" class="form-control">
                                    <option value="all" selected>All</option>
                                    <option value="CRITICAL">Critical</option>
                                    <option value="HIGH">High</option>
                                    <option value="MEDIUM">Medium</option>
                                    <option value="LOW">Low</option>
                                    <option value="UNKNOWN">Unknown</option>
                                </select>
                            </div>
                            <div class="input-group" style="width: 300px;">
                                <div class="input-group-prepend"><span class="input-group-text">Min CVEs</span></div>
                                <input type="range" id="minDegree" class="form-control" min="0" max="10" step="1" value="0" oninput="document.getElementById('minDegreeValue').textContent=this.value">
                                <div class="input-group-append"><span class="input-group-text" id="minDegreeValue">0</span></div>
                            </div>
                            <div class="input-group" style="width: 320px;">
                                <div class="input-group-prepend"><span class="input-group-text">Spacing</span></div>
                                <input type="range" id="spacingSlider" class="form-control" min="0" max="100" step="5" value="0" oninput="document.getElementById('spacingValue').textContent=this.value">
                                <div class="input-group-append"><span class="input-group-text" id="spacingValue">0</span></div>
                            </div>
                            <button class="btn btn-outline-dark" id="exitFocus" style="display:none;">Exit Focus</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="status-chip-row" id="statusChipRow">
                <span class="status-chip" id="chipPage"><span class="dot"></span><span class="label-text">Page 0/?</span></span>
                <span class="status-chip" id="chipLayout"><span class="dot"></span><span class="label-text">Layout: Structured</span></span>
                <span class="status-chip" id="chipSeverity"><span class="dot"></span><span class="label-text">Severity: All</span></span>
                <span class="status-chip" id="chipMinDegree"><span class="dot"></span><span class="label-text">Min CVEs: 0</span></span>
                <span class="status-chip" id="chipActor"><span class="dot"></span><span class="label-text">Actor: All</span></span>
                <span class="status-chip" id="chipLabels"><span class="dot"></span><span class="label-text">Labels: On</span></span>
                <span class="status-chip" id="chipFocus"><span class="dot"></span><span class="label-text">Focus Off</span></span>
            </div>

            <div class="status-bar">
                <div class="text-muted" id="statusText">Idle</div>
                <div class="flex-grow-1">
                    <div class="progress" style="display:none;" id="progressContainer">
                        <div id="loadProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuemin="0" aria-valuemax="100" style="width: 0%">0%</div>
                    </div>
                </div>
                <div class="text-muted" id="countsText">Nodes: 0, Links: 0</div>
            </div>
        </div>

        <div class="graph-surface">
            <div class="graph-main">
                <div id="chart"></div>
                <div class="info-box" id="infoBox"></div>
                <div class="loading-spinner" id="loadingSpinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="sr-only">Loading...</span>
                    </div>
                </div>
                <div class="floating-right">
                    <button class="btn btn-light btn-icon" id="zoomIn" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                    <button class="btn btn-light btn-icon" id="zoomOut" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                    <button class="btn btn-light btn-icon" id="zoomFit" title="Fit to Screen"><i class="fas fa-compress-arrows-alt"></i></button>
                    <button class="btn btn-light btn-icon" id="exportSvg" title="Export SVG"><i class="fas fa-file-download"></i></button>
                </div>
            </div>
            <aside class="graph-sidebar" id="insightPanel">
                <div class="sidebar-section">
                    <h5>Active Focus</h5>
                    <div class="focus-title" id="focusTitle">No selection yet</div>
                    <div class="focus-tabs" id="focusTabs">
                        <button class="focus-tab active" data-tab="overview">Overview</button>
                        <button class="focus-tab" data-tab="neighbors">Neighbors</button>
                    </div>
                    <div id="focusOverview">
                        <div class="focus-meta" id="focusMeta"></div>
                        <div class="focus-description" id="focusDescription"></div>
                        <div class="focus-pocs focus-section-hidden" id="focusPocs"></div>
                    </div>
                    <div id="focusNeighborsSection" class="focus-neighbors-wrapper">
                        <ul class="focus-neighbors" id="focusNeighbors"></ul>
                    </div>
                </div>
                <div class="sidebar-section">
                    <h5>Graph Snapshot</h5>
                    <div class="snapshot-row"><span>Total Nodes: </span><strong id="statNodes">0</strong><span class="delta" id="statNodesDelta"></span></div>
                    <div class="snapshot-row"><span>Total Links: </span><strong id="statLinks">0</strong><span class="delta" id="statLinksDelta"></span></div>
                    <div class="snapshot-row"><span>Actors: </span><strong id="statActors">0</strong><span class="delta" id="statActorsDelta"></span></div>
                    <div class="snapshot-row"><span>CVEs: </span><strong id="statCves">0</strong><span class="delta" id="statCvesDelta"></span></div>
                    <div class="quick-filters" id="severityQuickFilters">
                        <button class="severity-chip active" data-severity="all">All</button>
                        <button class="severity-chip" data-severity="CRITICAL"><span class="dot" style="background:#d62728;"></span>Critical <span id="sevCritical">0</span></button>
                        <button class="severity-chip" data-severity="HIGH"><span class="dot" style="background:#ff7f0e;"></span>High <span id="sevHigh">0</span></button>
                        <button class="severity-chip" data-severity="MEDIUM"><span class="dot" style="background:#ffbf00;"></span>Medium <span id="sevMedium">0</span></button>
                        <button class="severity-chip" data-severity="LOW"><span class="dot" style="background:#2ca02c;"></span>Low <span id="sevLow">0</span></button>
                        <button class="severity-chip" data-severity="UNKNOWN"><span class="dot" style="background:#6baed6;"></span>Unknown <span id="sevUnknown">0</span></button>
                    </div>
                </div>
                <div class="sidebar-section mini-map-card">
                    <h5>Mini Map</h5>
                    <canvas id="miniMap" width="200" height="140"></canvas>
                    <div class="mini-map-hint">Overview of node positions.</div>
                </div>
                <div class="sidebar-section">
                    <h5>Tips</h5>
                    <ul class="focus-neighbors" id="interactionTips"></ul>
                </div>
            </aside>
        </div>

    <script>
        let simulation;
        let currentPage = 1;
        let perPage = 25;
        let allNodes = [];
        let allLinks = [];
        let nodeMap = new Map(); // id -> node
        let linkSet = new Set(); // 'a|b' normalized id pairs
        let adjacency = new Map(); // id -> Set(neighborIds)
        let abortController = null;
        let searchedActor = '';
        let filterActors = false;
        let labelsOn = true;
        let sizeByDegree = true;
        let organicMode = false; // layout style toggle
        let severityFilter = 'all';
        let minDegree = 0;
        let focusMode = false;
        let focusedNodeId = null;
        let spotlightNodeId = null;
        let rootSvg = null;
        let zoomBehavior = null;
        let tooltip, infoBox; // overlays
        let actorLoadTimer = null;
        let loadAllTimer = null;
        let actorLoadActive = false;
        let loadAllActive = false;
        let actorDisplayName = '';
        let pageInfo = { current: 0, total: null };
        const POSITION_STORAGE_KEY = 'kev-graph-pos-v1';
        const MAX_POSITION_STORE = 400;
        const persistedPositions = loadPersistedPositions();
        const SEVERITY_ORDER = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'UNKNOWN'];
        let insightNode = null;
        let miniMapCanvas = null;
        let miniMapCtx = null;
        let miniMapPayload = null;
        let miniMapPending = false;
        let miniMapTick = 0;
        const MINIMAP_RENDER_INTERVAL = 160;
        let lastMiniMapRender = 0;
        let miniMapThrottleTimer = null;
        let hasInitialFit = false;
        let currentTransform = d3.zoomIdentity;
        let miniMapState = null;
        let chartWidth = 0;
        let chartHeight = 0;
        let lastSnapshot = null;
        let lastMiniMapNodes = [];
        let lastRenderedNodeCount = 0;
        let activeFocusTab = 'overview';
        let searchMatchIds = new Set();
        let lastActorSearchTerm = '';
        let canvas = null;
        let ctx = null;
        let currentRenderNodes = [];
        let currentRenderLinks = [];
        let currentDegreeMap = null;
        let spotlightFocusSet = null;
        let searchVisibleNodeSet = null;
        let searchHiddenActorSet = null;
        let focusHighlightId = null;
        let hoveredNode = null;
        let pointerDownNode = null;
        let isDraggingCanvas = false;
        let zoomTargetAlpha = 0.02;
        let canvasInteractionsBound = false;
        let spacingStrength = 0;
        let canvasWasPanned = false;

        document.getElementById('fetchData').addEventListener('click', function () {
            searchedActor = ''; // Clear searched actor when fetching general data
            actorDisplayName = '';
            const actorInput = document.getElementById('actorSearch');
            if (actorInput) actorInput.value = '';
            resetProgress();
            fetchData(currentPage);
            updateStatusChips();
        });

        document.getElementById('loadMoreData').addEventListener('click', function () {
            currentPage++;
            fetchData(currentPage);
        });

        document.getElementById('loadAll').addEventListener('click', function () {
            searchedActor = '';
            actorDisplayName = '';
            const actorInput = document.getElementById('actorSearch');
            if (actorInput) actorInput.value = '';
            startLoadAll();
            updateStatusChips();
        });

        document.getElementById('resetView').addEventListener('click', function () {
            stopSimulation();
            cancelCurrentRequest();
            cancelActorLoad();
            cancelLoadAll();
            d3.select("#chart").selectAll("*").remove();
            allNodes = [];
            allLinks = [];
            nodeMap.clear();
            linkSet.clear();
            adjacency.clear();
            currentPage = 1;
            searchedActor = ''; // Clear searched actor on reset
            minDegree = 0;
            spotlightNodeId = null;
            const minSlider = document.getElementById('minDegree');
            const minLabel = document.getElementById('minDegreeValue');
            if (minSlider) { minSlider.value = 0; }
            if (minLabel) { minLabel.textContent = '0'; }
            updateCounts();
            setStatus('Reset. Ready.');
            hideLoadingSpinner();
            hideProgress();
            document.getElementById('cancelSearch').style.display = 'none';
            actorDisplayName = '';
            pageInfo = { current: 0, total: null };
            hasInitialFit = false;
            rootSvg = null;
            zoomBehavior = null;
            tooltip = infoBox = null;
            canvas = null;
            ctx = null;
            currentRenderNodes = [];
            currentRenderLinks = [];
            currentDegreeMap = null;
            spotlightFocusSet = null;
            searchVisibleNodeSet = null;
            searchHiddenActorSet = null;
            hoveredNode = null;
            pointerDownNode = null;
            canvasInteractionsBound = false;
            spacingStrength = 0;
            const spacingSlider = document.getElementById('spacingSlider');
            if (spacingSlider) spacingSlider.value = 0;
            const spacingValue = document.getElementById('spacingValue');
            if (spacingValue) spacingValue.textContent = '0';
            clearActorSearchMatches();
            updateStatusChips();
            refreshSidebarFocus();
            updateGraphSnapshot([], []);
            scheduleMiniMapRender([]);
        });

        document.getElementById('searchByActor').addEventListener('click', function () {
            const actorInput = document.getElementById('actorSearch');
            actorDisplayName = actorInput.value.trim();
            if (!actorDisplayName) {
                clearActorSearchMatches({ reheatAlpha: 0.1 });
                return;
            }
            searchedActor = actorDisplayName.toLowerCase();
            if (performActorGraphSearch(actorDisplayName)) {
                document.getElementById('cancelSearch').style.display = 'none';
                hideProgress();
                updateStatusChips();
                refreshSidebarFocus();
                return;
            }
            clearActorSearchMatches();
            cancelCurrentRequest();
            fetchDataByActor(searchedActor);
            updateStatusChips();
            refreshSidebarFocus();
        });

        document.getElementById('cancelSearch').addEventListener('click', function () {
            cancelCurrentRequest(); // Cancel any ongoing request
            cancelActorLoad();
            document.getElementById('cancelSearch').style.display = 'none';
            hideProgress();
            setStatus('Canceled.');
            actorDisplayName = '';
            clearActorSearchMatches({ reheatAlpha: 0.1 });
            updateStatusChips();
            refreshSidebarFocus();
        });

        document.getElementById('actorSearch').addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                const actorInput = document.getElementById('actorSearch');
                actorDisplayName = actorInput.value.trim();
                if (!actorDisplayName) {
                    clearActorSearchMatches({ reheatAlpha: 0.1 });
                    return;
                }
                searchedActor = actorDisplayName.toLowerCase();
                if (performActorGraphSearch(actorDisplayName)) {
                    document.getElementById('cancelSearch').style.display = 'none';
                    hideProgress();
                    updateStatusChips();
                    refreshSidebarFocus();
                    return;
                }
                clearActorSearchMatches();
                cancelCurrentRequest();
                fetchDataByActor(searchedActor);
                updateStatusChips();
                refreshSidebarFocus();
            }
        });

        document.getElementById('clearActorSearch').addEventListener('click', function(){
            const actorInput = document.getElementById('actorSearch');
            if (actorInput) actorInput.value = '';
            actorDisplayName = '';
            searchedActor = '';
            clearActorSearchMatches({ reheatAlpha: 0.1 });
            updateStatusChips();
            refreshSidebarFocus();
            setStatus('Actor search cleared.');
        });

        document.getElementById('filterActorsToggle').addEventListener('change', function () {
            filterActors = this.checked;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.2 });
            updateStatusChips();
        });

        document.getElementById('labelsToggle').addEventListener('change', function () {
            labelsOn = this.checked;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.1 });
            updateStatusChips();
        });

        document.getElementById('sizeByDegreeToggle').addEventListener('change', function () {
            sizeByDegree = this.checked;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.12 });
        });

        document.getElementById('severityFilter').addEventListener('change', function () {
            severityFilter = this.value;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.22 });
            updateStatusChips();
            const container = document.getElementById('severityQuickFilters');
            if (container) {
                const btn = container.querySelector(`.severity-chip[data-severity="${severityFilter}"]`);
                if (btn) btn.classList.add('active');
            }
        });

        document.getElementById('perPage').addEventListener('change', function () {
            const val = parseInt(this.value, 10);
            perPage = Math.max(1, Math.min(100, isNaN(val) ? 25 : val));
            this.value = perPage;
        });

        document.getElementById('minDegree').addEventListener('input', function(){
            minDegree = parseInt(this.value, 10) || 0;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.22 });
            updateStatusChips();
        });

        document.getElementById('spacingSlider').addEventListener('input', function(){
            spacingStrength = parseInt(this.value, 10) || 0;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.18 });
        });

        document.getElementById('focusModeToggle').addEventListener('change', function(){
            focusMode = this.checked;
            if (!focusMode) {
                focusedNodeId = null;
                document.getElementById('exitFocus').style.display = 'none';
            }
            spotlightNodeId = null;
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.24 });
            updateStatusChips();
            refreshSidebarFocus();
        });

        (function bindSeverityQuickFilters(){
            const container = document.getElementById('severityQuickFilters');
            if (!container) return;
            container.addEventListener('click', (event) => {
                const btn = event.target.closest('.severity-chip');
                if (!btn) return;
                const value = btn.getAttribute('data-severity');
                if (!value) return;
                severityFilter = value;
                const select = document.getElementById('severityFilter');
                if (select) select.value = value;
                visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.22 });
                updateStatusChips();
            });
        })();

        (function bindFocusTabs(){
            const tabsContainer = document.getElementById('focusTabs');
            if (!tabsContainer) return;
            tabsContainer.addEventListener('click', (event) => {
                const btn = event.target.closest('.focus-tab');
                if (!btn) return;
                const tab = btn.getAttribute('data-tab');
                if (!tab) return;
                activeFocusTab = tab;
                applyFocusTabState();
            });
            applyFocusTabState();
        })();

        document.getElementById('exitFocus').addEventListener('click', function(){
            focusedNodeId = null;
            document.getElementById('exitFocus').style.display = 'none';
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.22 });
            updateStatusChips();
            refreshSidebarFocus();
        });

        // Navbar global search (CVE or Actor)
        document.getElementById('globalSearchBtn').addEventListener('click', () => {
            const q = document.getElementById('globalSearch').value.trim();
            if (!q) return;
            if (/^CVE-\d{4}-\d{4,}$/.test(q.toUpperCase())) {
                // zoom to CVE label if present
                focusOnNodeById(q.toUpperCase());
            } else {
                // treat as actor search
                document.getElementById('actorSearch').value = q;
                actorDisplayName = q;
                searchedActor = q.toLowerCase();
                if (performActorGraphSearch(actorDisplayName)) {
                    document.getElementById('cancelSearch').style.display = 'none';
                    hideProgress();
                    updateStatusChips();
                    refreshSidebarFocus();
                } else {
                    clearActorSearchMatches();
                    fetchDataByActor(searchedActor);
                    updateStatusChips();
                    refreshSidebarFocus();
                }
            }
        });

        // Zoom controls
        document.getElementById('zoomIn').addEventListener('click', () => zoomBy(1.2));
        document.getElementById('zoomOut').addEventListener('click', () => zoomBy(1/1.2));
        document.getElementById('zoomFit').addEventListener('click', () => fitToScreen());
        document.getElementById('exportSvg').addEventListener('click', () => exportSVG());

        // Layout toggle (Organic vs Structured)
        document.getElementById('layoutToggle').addEventListener('click', function(){
            organicMode = !organicMode;
            const btn = document.getElementById('layoutToggle');
            btn.classList.toggle('btn-success', organicMode);
            btn.classList.toggle('btn-info', !organicMode);
            btn.innerHTML = organicMode ? '<i class="fas fa-project-diagram"></i> Organic On' : '<i class="fas fa-project-diagram"></i> Organic';
            setStatus(organicMode ? 'Organic layout' : 'Structured layout');
            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: organicMode ? 0.32 : 0.28 });
            updateStatusChips();
        });

        function cancelCurrentRequest() {
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
        }

        function stopSimulation() {
            if (!simulation) return;
            simulation.stop();
            simulation.on('tick', null); // drop tick callback to avoid updates against cleared selections
            simulation = null;
        }

        function cancelActorLoad() {
            actorLoadActive = false;
            if (actorLoadTimer) {
                clearTimeout(actorLoadTimer);
                actorLoadTimer = null;
            }
        }

        function cancelLoadAll() {
            loadAllActive = false;
            if (loadAllTimer) {
                clearTimeout(loadAllTimer);
                loadAllTimer = null;
            }
        }

        function fetchData(page) {
            showLoadingSpinner();
            cancelActorLoad();
            cancelLoadAll();
            cancelCurrentRequest();
            const ctrl = new AbortController();
            abortController = ctrl;
            const signal = ctrl.signal;

            fetch(`/kev?page=${page}&per_page=${perPage}`, { signal })
                .then(response => response.json())
                .then(data => {
                    hideLoadingSpinner();
                    if (signal.aborted) return; // Check if the request was aborted
                    const formattedData = formatData(data.vulnerabilities);
                    mergeGraph(formattedData.nodes, formattedData.links);
                    const reheat = lastActorSearchTerm ? 0.18 : 0.24;
                    visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: reheat });
                    updateCounts();
                    if (lastActorSearchTerm) {
                        performActorGraphSearch(lastActorSearchTerm, { focus: false, updateStatus: false });
                    }
                    setStatus(`Page ${data.page}/${data.total_pages || '?'} loaded.`);
                    const current = typeof data.page === 'number' ? data.page : page;
                    pageInfo = {
                        current,
                        total: typeof data.total_pages === 'number' ? data.total_pages : pageInfo.total
                    };
                    updateStatusChips();
                })
                .catch(error => {
                    hideLoadingSpinner();
                    if (error.name === 'AbortError') {
                        console.log('Fetch request canceled');
                    } else {
                        console.error('Error fetching data:', error);
                        setStatus('Error fetching data');
                    }
                });
        }

        function fetchDataByActor(actor) {
            showLoadingSpinner();
            cancelActorLoad();
            cancelLoadAll();
            cancelCurrentRequest();
            const ctrl = new AbortController();
            abortController = ctrl;
            const signal = ctrl.signal;

            const encodedActor = encodeURIComponent(actor);
            fetch(`/kev?actor=${encodedActor}&page=${currentPage}&per_page=${perPage}`, { signal })
                .then(response => response.json())
                .then(data => {
                    hideLoadingSpinner();
                    if (signal.aborted) return; // Check if the request was aborted
                    const formattedData = formatData(data.vulnerabilities);
                    mergeGraph(formattedData.nodes, formattedData.links);
                    const reheat = lastActorSearchTerm ? 0.18 : 0.24;
                    visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: reheat });

                    // Show cancel button
                    document.getElementById('cancelSearch').style.display = 'inline-block';
                    setStatus(`Loaded page ${data.page}/${data.total_pages} for actor: ${actor}`);
                    showProgress();
                    updateProgress(data.page, data.total_pages);
                    pageInfo = {
                        current: typeof data.page === 'number' ? data.page : (pageInfo.current || 1),
                        total: typeof data.total_pages === 'number' ? data.total_pages : pageInfo.total
                    };
                    updateStatusChips();
                    performActorGraphSearch(actorDisplayName, { focus: true, updateStatus: false });

                    // Automatically load subsequent pages if total_pages > 1
                    if (data.total_pages > 1) {
                        loadMoreDataByActor(actor, data.total_pages);
                    }
                })
                .catch(error => {
                    hideLoadingSpinner();
                    if (error.name === 'AbortError') {
                        console.log('Fetch request canceled');
                    } else {
                        console.error('Error fetching data:', error);
                        setStatus('Error fetching actor data');
                    }
                });
        }

        function loadMoreDataByActor(actor, totalPages) {
            let page = 2;
            actorLoadActive = true;
            const encodedActor = encodeURIComponent(actor);

            const fetchPage = () => {
                if (!actorLoadActive) return;
                if (page > totalPages) {
                    actorLoadActive = false;
                    if (actorLoadTimer) {
                        clearTimeout(actorLoadTimer);
                        actorLoadTimer = null;
                    }
                    return; // End recursion
                }

                cancelCurrentRequest(); // Cancel any ongoing request before starting a new one
                const ctrl = new AbortController();
                abortController = ctrl;
                const signal = ctrl.signal;

                fetch(`/kev?actor=${encodedActor}&page=${page}&per_page=${perPage}`, { signal })
                    .then(response => response.json())
                    .then(data => {
                        if (!actorLoadActive || signal.aborted) return;
                        const formattedData = formatData(data.vulnerabilities);
                        mergeGraph(formattedData.nodes, formattedData.links);
                        const reheat = lastActorSearchTerm ? 0.14 : 0.2;
                        visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: reheat });
                        updateCounts();
                        showProgress();
                        updateProgress(page, totalPages);
                        pageInfo = { current: page, total: totalPages };
                        updateStatusChips();
                        performActorGraphSearch(actorDisplayName, { focus: false, updateStatus: false });
                        page++;
                        actorLoadTimer = setTimeout(() => {
                            actorLoadTimer = null;
                            fetchPage();
                        }, 1500); // 1.5s pause to avoid rate limits
                    })
                    .catch(error => {
                        actorLoadActive = false;
                        if (actorLoadTimer) {
                            clearTimeout(actorLoadTimer);
                            actorLoadTimer = null;
                        }
                        if (error.name === 'AbortError') {
                            console.log('Fetch request canceled');
                        } else {
                            console.error('Error fetching data:', error);
                            setStatus('Error while loading more pages');
                        }
                    });
            };

            fetchPage(); // Start fetching pages
        }

        function startLoadAll() {
            showProgress();
            cancelLoadAll();
            cancelActorLoad();
            cancelCurrentRequest();
            const ctrl = new AbortController();
            abortController = ctrl;
            const signal = ctrl.signal;
            loadAllActive = true;
            loadAllTimer = null;
            // First call to get total pages
            fetch(`/kev?page=1&per_page=${perPage}`, { signal })
                .then(r => r.json())
                .then(first => {
                    if (!loadAllActive || signal.aborted) return;
                    const formatted = formatData(first.vulnerabilities);
                    mergeGraph(formatted.nodes, formatted.links);
                    const initialReheat = lastActorSearchTerm ? 0.18 : 0.24;
                    visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: initialReheat });
                    updateCounts();
                    if (lastActorSearchTerm) {
                        performActorGraphSearch(lastActorSearchTerm, { focus: false, updateStatus: false });
                    }
                    const totalPages = first.total_pages;
                    updateProgress(1, totalPages);
                    setStatus(`Loading all pages: 1/${totalPages}`);
                    pageInfo = { current: 1, total: totalPages || pageInfo.total };
                    updateStatusChips();
                    // Sequentially fetch remaining pages
                    let p = 2;
                    const loop = () => {
                        if (!loadAllActive) return;
                        if (p > totalPages) {
                            loadAllActive = false;
                            if (loadAllTimer) {
                                clearTimeout(loadAllTimer);
                                loadAllTimer = null;
                            }
                            setStatus('All pages loaded.');
                            hideProgress();
                            pageInfo = { current: totalPages, total: totalPages };
                            updateStatusChips();
                            fitToScreen();
                            return;
                        }
                        cancelCurrentRequest();
                        const ctrl2 = new AbortController();
                        abortController = ctrl2;
                        const sig = ctrl2.signal;
                        fetch(`/kev?page=${p}&per_page=${perPage}`, { signal: sig })
                            .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
                            .then(data => {
                                if (sig.aborted) return;
                                if (!loadAllActive) return;
                                const f = formatData(data.vulnerabilities);
                                mergeGraph(f.nodes, f.links);
                                const stepReheat = lastActorSearchTerm ? 0.14 : 0.2;
                                visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: stepReheat });
                                updateCounts();
                                if (lastActorSearchTerm) {
                                    performActorGraphSearch(lastActorSearchTerm, { focus: false, updateStatus: false });
                                }
                                updateProgress(p, totalPages);
                                setStatus(`Loading all pages: ${p}/${totalPages}`);
                                pageInfo = { current: p, total: totalPages };
                                updateStatusChips();
                                p++;
                                loadAllTimer = setTimeout(() => {
                                    loadAllTimer = null;
                                    loop();
                                }, 1500); // 1.5s pause to avoid rate limits
                            })
                            .catch(err => {
                                loadAllActive = false;
                                if (loadAllTimer) {
                                    clearTimeout(loadAllTimer);
                                    loadAllTimer = null;
                                }
                                if (err.name !== 'AbortError') {
                                    console.error(err);
                                    setStatus('Error during Load All');
                                }
                            });
                    };
                    loop();
                })
                .catch(err => {
                    loadAllActive = false;
                    if (loadAllTimer) {
                        clearTimeout(loadAllTimer);
                        loadAllTimer = null;
                    }
                    if (err.name !== 'AbortError') {
                        console.error(err);
                        setStatus('Error starting Load All');
                    }
                });
        }

        // Helpers to parse and normalize actor names that may be comma-separated
        function normalizeActorName(name) {
            if (!name && name !== 0) return null;
            let s = ('' + name).trim();
            // strip quotes and collapse spaces
            s = s.replace(/^['"\s]+|['"\s]+$/g, '').replace(/\s+/g, ' ');
            return s.length ? s : null;
        }

        // Actor exclusions: easily extendable lists
        const ACTOR_EXACT_EXCLUDE = [
            'vulnerability advisory',
            'n/a',
            'unknown',
            'malware advisory',
            'threat',
            'informational',
            'threat analysis',
            'a few critical',
            'kaseya vsa',
            'the state of colorado',
            'cyber threat',
            'global group',
            ':core.vmware.com/resource/vmsa-2023-0023-questions-answers#introduction',
            
        ];
        const ACTOR_CONTAINS_EXCLUDE = [
            'brian sabey',
            'threat intel report',
            'ioc-'
        ];

        function shouldExcludeActor(name) {
            if (name == null) return true;
            const val = ('' + name).trim().toLowerCase();
            if (!val) return true;
            if (ACTOR_EXACT_EXCLUDE.includes(val)) return true;
            for (const sub of ACTOR_CONTAINS_EXCLUDE) {
                if (val.includes(sub)) return true;
            }
            return false;
        }

        // Canonical mapping for vendor-specific actor names (lowercase keys)
        // Extend this as needed to unify naming across data sources
        const ACTOR_CANONICAL_MAP = {
            'lazarus': 'Lazarus',
            'lazarus group': 'Lazarus',
            'clop': 'cl0p',
            'xe': 'XE Group',
            'xe group': 'XE Group',
            'wannacry': 'WannaCry',
            'turla group': 'Turla',
            'krypton': 'Turla',
            'venomous bear': 'Turla',
            'uroburos': 'Turla',
            'andariel': 'Onyx Sleet',
            'silent chollima': 'Onyx Sleet',
            'chollima': 'Onyx Sleet',
            'plutonium': 'Onyx Sleet',
            'play ransomware group': 'Play Ransomware',
            'play': 'Play Ransomware',
        };

        function canonicalizeActorName(name) {
            if (!name) return name;
            const key = ('' + name).trim().toLowerCase();
            return ACTOR_CANONICAL_MAP[key] || name;
        }

        function splitActorField(value) {
            if (value == null) return [];
            const raw = '' + value;
            if (raw.includes(',')) {
                return raw
                    .split(',')
                    .map(normalizeActorName)
                    .filter(Boolean)
                    .filter(n => !shouldExcludeActor(n))
                    .map(canonicalizeActorName);
            }
            const single = normalizeActorName(raw);
            return single && !shouldExcludeActor(single) ? [canonicalizeActorName(single)] : [];
        }

        function extractActors(threatData) {
            const srcA = Array.isArray(threatData?.adversaries) ? threatData.adversaries : [];
            const srcC = Array.isArray(threatData?.communityAdversaries) ? threatData.communityAdversaries : [];
            const collected = [];
            for (const entry of [...srcA, ...srcC]) {
                if (Array.isArray(entry)) {
                    for (const sub of entry) collected.push(...splitActorField(sub));
                } else {
                    collected.push(...splitActorField(entry));
                }
            }
            // de-duplicate case-insensitively, preserve first casing
            const seen = new Set();
            const out = [];
            for (const n of collected) {
                const key = n.toLowerCase();
                if (!seen.has(key)) { seen.add(key); out.push(n); }
            }
            return out;
        }

        const MAX_DESCRIPTION_LENGTH = 500;
        const MAX_GITHUB_POC_LINKS = 10;

        function compactCveDetails(vuln) {
            if (!vuln) {
                return {
                    cveID: 'Unknown',
                    vulnerabilityName: 'Unknown',
                    severity: 'UNKNOWN',
                    dateAdded: 'Unknown',
                    shortDescription: '',
                    githubPocs: []
                };
            }
            const severity = (vuln.nvdData?.[0]?.baseSeverity || 'UNKNOWN').toUpperCase();
            const pocSet = new Set();
            const pocList = [];
            if (Array.isArray(vuln.githubPocs)) {
                for (const poc of vuln.githubPocs) {
                    if (typeof poc !== 'string') continue;
                    const trimmed = poc.trim();
                    if (!trimmed || pocSet.has(trimmed)) continue;
                    pocSet.add(trimmed);
                    pocList.push(trimmed);
                    if (pocList.length >= MAX_GITHUB_POC_LINKS) break;
                }
            }
            const desc = vuln.shortDescription || '';
            const truncatedDesc = desc.length > MAX_DESCRIPTION_LENGTH ? desc.slice(0, MAX_DESCRIPTION_LENGTH) + '...' : desc;
            return {
                cveID: vuln.cveID,
                vulnerabilityName: vuln.vulnerabilityName || vuln.cveID || 'Unknown',
                severity,
                dateAdded: vuln.dateAdded || 'Unknown',
                shortDescription: truncatedDesc,
                githubPocs: pocList
            };
        }

        function formatData(vulnerabilities) {
            const nodes = [];
            const links = [];
            const actorMap = new Map();

            vulnerabilities.forEach(vuln => {
                const threatData = vuln.openThreatData?.[0] || {};
                const actors = extractActors(threatData);

                if (actors.length > 0) {
                    const cveNode = { id: vuln.cveID, name: vuln.cveID, type: 'cve', details: compactCveDetails(vuln) };
                    nodes.push(cveNode);

                    actors.forEach(actorName => {
                        const actor = actorName; // already normalized
                        const actorNode = { id: actor, name: actor, type: 'actor' };
                        if (!actorMap.has(actor)) {
                            actorMap.set(actor, actorNode);
                            nodes.push(actorNode);
                        }
                        // Direction should show actor influencing CVE, so orient edges actor -> CVE
                        links.push({ source: actor, target: cveNode.id });
                    });
                }
            });

            return { nodes, links };
        }

        // Update the visualizeData function to filter nodes based on the searched actor
        function renderGraph(data, { reheatAlpha = null } = {}) {
            // 1) Filter data
            let filteredNodes = data.nodes;
            let filteredLinks = data.links;
            miniMapTick = 0;
            const nodeCountChanged = filteredNodes.length !== lastRenderedNodeCount;

            // Filter nodes and links if the filter toggle is active
            if (filterActors && searchedActor) {
                // Find all actor nodes that match the search term
                const matchingActors = filteredNodes.filter(node => node.type === 'actor' && node.name.toLowerCase().includes(searchedActor));

                // Collect IDs of the matching actors
                const matchingActorIds = new Set(matchingActors.map(actor => actor.id));

                // Filter the nodes to include only CVEs and the matching actors
                filteredNodes = filteredNodes.filter(node => node.type === 'cve' || matchingActorIds.has(node.id));

                // Create a set of matching node IDs
                const matchingNodeIds = new Set(filteredNodes.map(node => node.id));

                // Filter links to include only those that connect to the matching nodes
                filteredLinks = filteredLinks.filter(link => {
                    const s = getLinkEndId(link.source);
                    const t = getLinkEndId(link.target);
                    return matchingNodeIds.has(s) && matchingNodeIds.has(t);
                });
            }

            // Filter by severity (for CVE nodes only)
            if (severityFilter !== 'all') {
                const keep = new Set(filteredNodes.filter(n => {
                    if (n.type !== 'cve') return true;
                    const sev = n.details?.severity || 'UNKNOWN';
                    return sev === severityFilter;
                }).map(n => n.id));
                filteredNodes = filteredNodes.filter(n => keep.has(n.id));
                filteredLinks = filteredLinks.filter(l => keep.has(getLinkEndId(l.source)) && keep.has(getLinkEndId(l.target)));
            }

            // Actor min-CVEs filter (actors only). Compute actor->num CVEs and filter.
            const actorCveCounts = computeActorCveCounts(filteredNodes, filteredLinks);
            // Dynamically adapt slider max to current dataset
            updateMinCveSlider(actorCveCounts);
            if (minDegree > 0) {
                const actorsToKeep = new Set(filteredNodes
                    .filter(n => n.type !== 'actor' || (actorCveCounts.get(n.id) || 0) >= minDegree)
                    .map(n => n.id));
                filteredNodes = filteredNodes.filter(n => actorsToKeep.has(n.id));
                filteredLinks = filteredLinks.filter(l => actorsToKeep.has(getLinkEndId(l.source)) && actorsToKeep.has(getLinkEndId(l.target)));
                // Drop isolated CVEs
                const idsInLinks = new Set();
                for (const l of filteredLinks) { idsInLinks.add(getLinkEndId(l.source)); idsInLinks.add(getLinkEndId(l.target)); }
                filteredNodes = filteredNodes.filter(n => idsInLinks.has(n.id));
            }

            // Focus mode: keep only focused node + its neighbors
            if (focusMode && focusedNodeId) {
                const allowed = new Set([focusedNodeId]);
                (adjacency.get(focusedNodeId) || new Set()).forEach(id => allowed.add(id));
                filteredNodes = filteredNodes.filter(n => allowed.has(n.id));
                filteredLinks = filteredLinks.filter(l => allowed.has(getLinkEndId(l.source)) && allowed.has(getLinkEndId(l.target)));
            }

            updateGraphSnapshot(filteredNodes, filteredLinks);
            currentRenderNodes = filteredNodes;
            currentRenderLinks = filteredLinks;

            const width = document.getElementById('chart').clientWidth;
            const height = document.getElementById('chart').clientHeight;
            chartWidth = width;
            chartHeight = height;

            ensureScene(width, height);

            // Seed positions for nodes that don't have positions yet
            filteredNodes.forEach(node => {
                if (typeof node.x !== 'number' || typeof node.y !== 'number') {
                    node.x = Math.random() * width;
                    node.y = Math.random() * height;
                }
            });

            computeAdjacency(filteredNodes, filteredLinks);
            const degreeMap = computeDegreeMap(filteredNodes, filteredLinks);
            currentDegreeMap = degreeMap;
            const hasFreshNodes = filteredNodes.some(n => n.__fresh);
            if (hasFreshNodes) {
                filteredNodes.forEach(n => { if (n.__fresh) n.__fresh = false; });
            }
            refreshSidebarFocus();
            scheduleMiniMapRender(filteredNodes);

            refreshSpotlightStyles();
            refreshSearchMatchStyles();
            applySearchFocus();

            drawScene();

            // 5) Init or update simulation
            if (!simulation) {
                simulation = d3.forceSimulation(filteredNodes)
                    .force('link', d3.forceLink(filteredLinks).id(d => d.id).distance(d => getLinkDistance(d)).strength(0.6))
                    .force('charge', d3.forceManyBody().strength(-110))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(d => getRadius(d, degreeMap) + 6).strength(1))
                    .velocityDecay(0.64)
                    .on('end', persistNodePositions);
            }

            simulation.nodes(filteredNodes).on('tick', () => {
                miniMapTick = (miniMapTick + 1) % 4;
                if (miniMapTick === 0) scheduleMiniMapRender(filteredNodes);
                drawScene();
            });
            simulation.force('link').links(filteredLinks);
            // apply layout-specific forces
            let targetReheat = reheatAlpha;
            if (targetReheat == null) {
                targetReheat = (hasFreshNodes || nodeCountChanged) ? (organicMode ? 0.18 : 0.16) : 0.06;
            }
            applyForces(degreeMap, width, height, { reheatAlpha: targetReheat });
            simulation.on('end', () => {
                persistNodePositions();
            });
            lastRenderedNodeCount = filteredNodes.length;

            d3.select("body").on("click", function (event) {
                const isOutside = !event.target.closest("#chart") && !event.target.closest(".info-box");
                if (isOutside) {
                    tooltip.transition().duration(300).style("opacity", 0);
                    infoBox.transition().duration(300).style("opacity", 0);
                }
            });

            if (!hasInitialFit && filteredNodes.length) {
                hasInitialFit = true;
                setTimeout(() => fitToScreen(), 60);
            }

            updateStatusChips();
        }

        let pendingRender = null;
        let renderScheduled = false;

        function visualizeData(data, { immediate = false, reheatAlpha = null } = {}) {
            if (!data || typeof data !== 'object') return;
            if (immediate) {
                pendingRender = null;
                renderScheduled = false;
                renderGraph(data, { reheatAlpha });
                return;
            }
            pendingRender = { data, reheatAlpha };
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderScheduled = false;
                    const payload = pendingRender;
                    pendingRender = null;
                    if (payload) renderGraph(payload.data, { reheatAlpha: payload.reheatAlpha });
                });
            }
        }

        function ensureScene(width, height) {
            const chart = d3.select('#chart');
            if (!canvas) {
                canvas = chart.append('canvas').attr('width', width).attr('height', height).style('position', 'absolute').style('top', 0).style('left', 0).node();
                ctx = canvas.getContext('2d');
            } else {
                d3.select(canvas).attr('width', width).attr('height', height);
            }
            if (!rootSvg) {
                rootSvg = chart.append('svg').attr('width', width).attr('height', height).style('position', 'absolute').style('top', 0).style('left', 0).style('pointer-events', 'none');
                tooltip = chart.append('div').attr('class', 'tooltip');
                infoBox = d3.select('#infoBox');
            } else {
                rootSvg.attr('width', width).attr('height', height);
            }
            if (!zoomBehavior) {
                zoomBehavior = d3.zoom()
                    .scaleExtent([0.2, 5])
                    .filter(event => {
                        if (!canvas) return true;
                        if (event.type === 'wheel') return true;
                        if (event.type === 'dblclick') return false;
                        if (event.type === 'mousedown' || event.type === 'pointerdown' || event.type === 'touchstart') {
                            return !hitTestEvent(event);
                        }
                        return true;
                    })
                    .on('zoom', (event) => {
                        currentTransform = event.transform;
                        if (event.sourceEvent && event.sourceEvent.type && event.sourceEvent.type.startsWith('pointer')) {
                            canvasWasPanned = true;
                        }
                        scheduleMiniMapRender(lastMiniMapNodes);
                        drawScene();
                    }).wheelDelta(event => {
                        const base = event.deltaMode === 1 ? 0.05 : 0.0025;
                        return -event.deltaY * base;
                    });
            }
            d3.select(canvas).call(zoomBehavior);
            if (!canvasInteractionsBound) {
                attachCanvasInteractions();
                canvasInteractionsBound = true;
            }
        }

        const darkThemeToggle = document.getElementById('darkThemeToggle');
        const body = document.body;

        const userThemePreference = localStorage.getItem('darkTheme');
        if (userThemePreference === 'true') {
            body.classList.add('bg-dark');
            body.classList.add('text-light');
            darkThemeToggle.checked = true;
        }

        darkThemeToggle.addEventListener('change', () => {
            if (darkThemeToggle.checked) {
                body.classList.add('bg-dark');
                body.classList.add('text-light');
                localStorage.setItem('darkTheme', 'true');
            } else {
                body.classList.remove('bg-dark');
                body.classList.remove('text-light');
                localStorage.setItem('darkTheme', 'false');
            }
        });

        function showLoadingSpinner() {
            document.getElementById('loadingSpinner').style.display = 'block';
        }

        function hideLoadingSpinner() {
            document.getElementById('loadingSpinner').style.display = 'none';
        }

        // Graph merge + helpers
        function mergeGraph(newNodes, newLinks) {
            // Precompute neighbors present in current graph for seeding positions
            const existingIds = new Set(allNodes.map(n => n.id));
            const neighborMap = new Map(); // id -> Set(neighborIds)
            for (const l of newLinks) {
                const s = typeof l.source === 'string' ? l.source : l.source.id;
                const t = typeof l.target === 'string' ? l.target : l.target.id;
                if (!neighborMap.has(s)) neighborMap.set(s, new Set());
                if (!neighborMap.has(t)) neighborMap.set(t, new Set());
                neighborMap.get(s).add(t);
                neighborMap.get(t).add(s);
            }

            for (const n of newNodes) {
                if (!nodeMap.has(n.id)) {
                    // Seed new node position near an existing neighbor if possible
                    let seeded = false;
                    const stored = persistedPositions.get(n.id);
                    if (stored && typeof stored.x === 'number' && typeof stored.y === 'number') {
                        n.x = stored.x;
                        n.y = stored.y;
                        seeded = true;
                    }
                    const neighSet = neighborMap.get(n.id) || new Set();
                    if (!seeded) {
                        for (const nid of neighSet) {
                            if (existingIds.has(nid)) {
                                const neighbor = nodeMap.get(nid) || allNodes.find(x => x.id === nid);
                                if (neighbor && typeof neighbor.x === 'number' && typeof neighbor.y === 'number') {
                                    const jitter = () => (Math.random() - 0.5) * 40;
                                    n.x = neighbor.x + jitter();
                                    n.y = neighbor.y + jitter();
                                    seeded = true;
                                    break;
                                }
                            }
                        }
                    }
                    n.__fresh = true;
                    nodeMap.set(n.id, n);
                    allNodes.push(n);
                }
            }

            for (const l of newLinks) {
                const a = l.source;
                const b = l.target;
                const s = typeof a === 'string' ? a : a.id;
                const t = typeof b === 'string' ? b : b.id;
                const key = s < t ? `${s}|${t}` : `${t}|${s}`;
                if (!linkSet.has(key)) {
                    linkSet.add(key);
                    allLinks.push({ source: s, target: t });
                }
            }
        }

        function getLinkEndId(end) { return typeof end === 'string' ? end : end.id; }

        function computeAdjacency(nodes, links) {
            adjacency.clear();
            for (const n of nodes) adjacency.set(n.id, new Set());
            for (const l of links) {
                const s = getLinkEndId(l.source);
                const t = getLinkEndId(l.target);
                if (!adjacency.has(s)) adjacency.set(s, new Set());
                if (!adjacency.has(t)) adjacency.set(t, new Set());
                adjacency.get(s).add(t);
                adjacency.get(t).add(s);
            }
        }

        function computeDegreeMap(nodes, links) {
            const m = new Map();
            for (const n of nodes) m.set(n.id, 0);
            for (const l of links) {
                m.set(getLinkEndId(l.source), (m.get(getLinkEndId(l.source)) || 0) + 1);
                m.set(getLinkEndId(l.target), (m.get(getLinkEndId(l.target)) || 0) + 1);
            }
            return m;
        }

        // Counts, for each actor, how many CVEs it is associated with in the current dataset
        function computeActorCveCounts(nodes, links) {
            const types = new Map(nodes.map(n => [n.id, n.type]));
            const counts = new Map();
            for (const l of links) {
                const s = getLinkEndId(l.source);
                const t = getLinkEndId(l.target);
                const ts = types.get(s);
                const tt = types.get(t);
                if (ts === 'actor' && tt === 'cve') counts.set(s, (counts.get(s) || 0) + 1);
                if (tt === 'actor' && ts === 'cve') counts.set(t, (counts.get(t) || 0) + 1);
            }
            return counts;
        }

        function updateMinCveSlider(countMap) {
            const slider = document.getElementById('minDegree');
            const label = document.getElementById('minDegreeValue');
            if (!slider) return;
            let max = 0;
            countMap.forEach(v => { if (v > max) max = v; });
            // keep at least 10 for a reasonable range when small graphs
            const newMax = Math.max(10, max);
            if (parseInt(slider.max, 10) !== newMax) {
                slider.max = String(newMax);
            }
            // clamp current value
            if (minDegree > newMax) {
                minDegree = newMax;
                slider.value = String(minDegree);
                if (label) label.textContent = String(minDegree);
            }
        }

        function severityColor(d) {
            const sev = d.details?.severity || 'UNKNOWN';
            switch (sev) {
                case 'LOW': return '#2ca02c';
                case 'MEDIUM': return '#ffbf00';
                case 'HIGH': return '#ff7f0e';
                case 'CRITICAL': return '#d62728';
                default: return '#6baed6';
            }
        }

        function getRadius(d, degreeMap) {
            if (d.type === 'actor') return 10 + Math.min(10, (degreeMap.get(d.id) || 1) * 0.8);
            if (!sizeByDegree) return 8;
            const deg = degreeMap.get(d.id) || 1;
            return 6 + Math.min(12, Math.sqrt(deg) * 3);
        }

        function getLinkDistance(l) {
            const s = getLinkEndId(l.source);
            const t = getLinkEndId(l.target);
            const base = organicMode ? 150 : 90;
            return base + (s.startsWith('CVE-') || t.startsWith('CVE-') ? 30 : 0);
        }

        function loadPersistedPositions() {
            try {
                const raw = localStorage.getItem(POSITION_STORAGE_KEY);
                if (!raw) return new Map();
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return new Map();
                const map = new Map();
                for (const entry of parsed) {
                    if (Array.isArray(entry) && entry.length >= 3) {
                        const [id, x, y] = entry;
                        if (typeof id === 'string' && Number.isFinite(x) && Number.isFinite(y)) {
                            map.set(id, { x, y });
                        }
                    }
                }
                return map;
            } catch (err) {
                console.warn('Failed to load persisted positions', err);
                return new Map();
            }
        }

        function persistNodePositions() {
            try {
                const entries = [];
                for (const node of allNodes) {
                    if (typeof node?.x === 'number' && typeof node?.y === 'number') {
                        entries.push([node.id, Number(node.x.toFixed(1)), Number(node.y.toFixed(1))]);
                        if (entries.length >= MAX_POSITION_STORE) break;
                    }
                }
                localStorage.setItem(POSITION_STORAGE_KEY, JSON.stringify(entries));
                persistedPositions.clear();
                for (const [id, x, y] of entries) {
                    persistedPositions.set(id, { x, y });
                }
            } catch (err) {
                console.warn('Failed to persist positions', err);
            }
        }

        function updateGraphSnapshot(nodes, links) {
            const nodeEl = document.getElementById('statNodes');
            const linkEl = document.getElementById('statLinks');
            const actorEl = document.getElementById('statActors');
            const cveEl = document.getElementById('statCves');
            if (nodeEl) nodeEl.textContent = nodes.length;
            if (linkEl) linkEl.textContent = links.length;
            let actorCount = 0;
            let cveCount = 0;
            const severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
            for (const n of nodes) {
                if (n.type === 'actor') {
                    actorCount++;
                } else if (n.type === 'cve') {
                    cveCount++;
                    const sev = (n.details?.severity || 'UNKNOWN').toUpperCase();
                    if (severityCounts[sev] == null) severityCounts.UNKNOWN += 1;
                    else severityCounts[sev] += 1;
                }
            }
            if (actorEl) actorEl.textContent = actorCount;
            if (cveEl) cveEl.textContent = cveCount;
            const severityMap = {
                CRITICAL: document.getElementById('sevCritical'),
                HIGH: document.getElementById('sevHigh'),
                MEDIUM: document.getElementById('sevMedium'),
                LOW: document.getElementById('sevLow'),
                UNKNOWN: document.getElementById('sevUnknown')
            };
            for (const key of Object.keys(severityMap)) {
                const el = severityMap[key];
                if (el) el.textContent = severityCounts[key] ?? 0;
            }
            if (lastSnapshot) {
                setDelta('statNodesDelta', nodes.length - lastSnapshot.nodes);
                setDelta('statLinksDelta', links.length - lastSnapshot.links);
                setDelta('statActorsDelta', actorCount - lastSnapshot.actors);
                setDelta('statCvesDelta', cveCount - lastSnapshot.cves);
            } else {
                setDelta('statNodesDelta', null);
                setDelta('statLinksDelta', null);
                setDelta('statActorsDelta', null);
                setDelta('statCvesDelta', null);
            }
            lastSnapshot = {
                nodes: nodes.length,
                links: links.length,
                actors: actorCount,
                cves: cveCount,
                severity: severityCounts
            };
        }

        function ensureMiniMapContext() {
            if (!miniMapCanvas) {
                miniMapCanvas = document.getElementById('miniMap');
                if (miniMapCanvas) {
                    miniMapCanvas.style.cursor = 'grab';
                    miniMapCanvas.addEventListener('pointerdown', handleMiniMapPointer);
                }
            }
            if (miniMapCanvas && !miniMapCtx) {
                miniMapCtx = miniMapCanvas.getContext('2d');
            }
        }

        function handleMiniMapPointer(event) {
            if (!miniMapState || !miniMapCanvas || !canvas || !zoomBehavior) return;
            event.preventDefault();
            const rect = miniMapCanvas.getBoundingClientRect();
            const updateView = (clientX, clientY, withTransition) => {
                const mx = clientX - rect.left;
                const my = clientY - rect.top;
                const { minX, minY, scale } = miniMapState;
                const targetX = minX + mx / scale;
                const targetY = minY + my / scale;
                const k = currentTransform.k;
                const newTransform = d3.zoomIdentity.translate(chartWidth / 2, chartHeight / 2).scale(k).translate(-targetX, -targetY);
                const canvasSel = d3.select(canvas);
                if (withTransition) {
                    canvasSel.transition().duration(160).call(zoomBehavior.transform, newTransform);
                } else {
                    canvasSel.call(zoomBehavior.transform, newTransform);
                }
            };
            miniMapCanvas.setPointerCapture(event.pointerId);
            miniMapCanvas.style.cursor = 'grabbing';
            updateView(event.clientX, event.clientY, true);

            const pointerMove = (moveEvent) => {
                updateView(moveEvent.clientX, moveEvent.clientY, false);
            };

            const pointerUp = () => {
                miniMapCanvas.style.cursor = 'grab';
                try { miniMapCanvas.releasePointerCapture(event.pointerId); } catch (_) { }
                miniMapCanvas.removeEventListener('pointerup', pointerUp);
                miniMapCanvas.removeEventListener('pointerleave', pointerUp);
                miniMapCanvas.removeEventListener('pointermove', pointerMove);
            };

            miniMapCanvas.addEventListener('pointermove', pointerMove);
            miniMapCanvas.addEventListener('pointerup', pointerUp);
            miniMapCanvas.addEventListener('pointerleave', pointerUp);
        }

        function scheduleMiniMapRender(nodes) {
            ensureMiniMapContext();
            if (!miniMapCtx) return;
            lastMiniMapNodes = Array.isArray(nodes) ? nodes : [];
            miniMapPayload = lastMiniMapNodes;
            if (miniMapPending) return;
            const fire = () => {
                miniMapThrottleTimer = null;
                miniMapPending = true;
                requestAnimationFrame(() => {
                    miniMapPending = false;
                    lastMiniMapRender = performance.now();
                    drawMiniMap();
                });
            };
            const now = performance.now();
            const delta = now - lastMiniMapRender;
            if (delta >= MINIMAP_RENDER_INTERVAL) {
                fire();
            } else if (!miniMapThrottleTimer) {
                miniMapThrottleTimer = setTimeout(fire, MINIMAP_RENDER_INTERVAL - delta);
            }
        }

        function drawScene() {
            if (!ctx || !canvas) return;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(currentTransform.x, currentTransform.y);
            ctx.scale(currentTransform.k, currentTransform.k);

            const linkAlphaBase = 0.35;
            const nodeDimAlpha = 0.22;
            const searchDimAlpha = 0.3;
            const spotlightActive = Boolean(spotlightNodeId && spotlightFocusSet);

            ctx.lineCap = 'round';
            ctx.globalAlpha = 1;

            for (const link of currentRenderLinks) {
                const source = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
                const target = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
                if (!source || !target) continue;
                if (searchHiddenActorSet && ((source.type === 'actor' && searchHiddenActorSet.has(source.id)) || (target.type === 'actor' && searchHiddenActorSet.has(target.id)))) continue;
                if (spotlightActive && (!spotlightFocusSet.has(source.id) || !spotlightFocusSet.has(target.id))) continue;
                let alpha = linkAlphaBase;
                if (searchVisibleNodeSet && (!searchVisibleNodeSet.has(source.id) || !searchVisibleNodeSet.has(target.id))) alpha = Math.min(alpha, 0.1);
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
            for (const node of currentRenderNodes) {
                if (!node) continue;
                if (searchHiddenActorSet && node.type === 'actor' && searchHiddenActorSet.has(node.id)) continue;
                if (spotlightActive && !spotlightFocusSet.has(node.id)) continue;
                const radius = Math.max(2, getRadius(node, currentDegreeMap || new Map()));
                let fill = node.type === 'actor' ? '#ff5733' : severityColor(node);
                let alpha = 1;
                if (searchVisibleNodeSet && !searchVisibleNodeSet.has(node.id)) alpha = Math.min(alpha, searchDimAlpha);

                let halo = false;
                if (node.type === 'cve') {
                    const hasPoc = getValidGithubPocs(node).length > 0;
                    if (hasPoc) halo = true;
                }

                if (halo) {
                    ctx.globalAlpha = Math.min(alpha, 0.65);
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(255, 153, 0, 0.35)';
                    ctx.arc(node.x, node.y, radius + 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.fillStyle = fill;
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();

                if (searchMatchIds.has(node.id)) {
                    ctx.globalAlpha = 1;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#ff9800';
                    ctx.stroke();
                } else if (spotlightNodeId === node.id) {
                    ctx.globalAlpha = 1;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#3290ff';
                    ctx.stroke();
                }
                if (focusHighlightId && node.id === focusHighlightId) {
                    ctx.globalAlpha = 1;
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#ffd54f';
                    ctx.stroke();
                }
                if (hoveredNode && hoveredNode.id === node.id) {
                    ctx.globalAlpha = 1;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#ffffff';
                    ctx.stroke();
                }
            }

            if (labelsOn || focusMode || (searchMatchIds && searchMatchIds.size)) {
                ctx.font = `${Math.max(10, 12 / currentTransform.k)}px sans-serif`;
                ctx.textBaseline = 'middle';
                for (const node of currentRenderNodes) {
                    if (!node || !node.name) continue;
                    if (searchHiddenActorSet && node.type === 'actor' && searchHiddenActorSet.has(node.id)) continue;
                    if (spotlightActive && !spotlightFocusSet.has(node.id)) continue;
                    if (!labelsOn && node.type !== 'actor' && !searchMatchIds.has(node.id) && !(spotlightFocusSet && spotlightFocusSet.has(node.id))) continue;
                    ctx.globalAlpha = 0.95;
                    ctx.fillStyle = body.classList.contains('bg-dark') ? '#E0E0E0' : '#000';
                    ctx.fillText(node.name, node.x + 6, node.y);
                }
            }

            ctx.restore();
        }

        function drawMiniMap() {
            ensureMiniMapContext();
            if (!miniMapCtx || !miniMapCanvas) return;
            const ctx = miniMapCtx;
            const canvas = miniMapCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const nodes = Array.isArray(miniMapPayload) ? miniMapPayload : [];
            if (!nodes.length) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const node of nodes) {
                if (typeof node.x === 'number' && typeof node.y === 'number') {
                    if (node.x < minX) minX = node.x;
                    if (node.x > maxX) maxX = node.x;
                    if (node.y < minY) minY = node.y;
                    if (node.y > maxY) maxY = node.y;
                }
            }
            if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return;
            const padding = 12;
            const width = Math.max(maxX - minX, 1);
            const height = Math.max(maxY - minY, 1);
            const scale = Math.min((canvas.width - padding * 2) / width, (canvas.height - padding * 2) / height);
            ctx.save();
            ctx.translate(padding, padding);
            for (const node of nodes) {
                if (typeof node.x !== 'number' || typeof node.y !== 'number') continue;
                const x = (node.x - minX) * scale;
                const y = (node.y - minY) * scale;
                ctx.beginPath();
                ctx.fillStyle = node.type === 'actor' ? '#ff5733' : severityColor(node);
                ctx.arc(x, y, node.type === 'actor' ? 3.5 : 3, 0, Math.PI * 2);
                ctx.fill();
            }
            const highlightId = focusMode && focusedNodeId ? focusedNodeId : (insightNode ? insightNode.id : null);
            if (highlightId) {
                const focusNode = nodes.find(n => n.id === highlightId);
                if (focusNode && typeof focusNode.x === 'number' && typeof focusNode.y === 'number') {
                    ctx.beginPath();
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = focusMode ? '#0052cc' : '#3290ff';
                    ctx.arc((focusNode.x - minX) * scale, (focusNode.y - minY) * scale, 6, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            if (chartWidth && chartHeight) {
                const viewMinX = -currentTransform.x / currentTransform.k;
                const viewMaxX = (chartWidth - currentTransform.x) / currentTransform.k;
                const viewMinY = -currentTransform.y / currentTransform.k;
                const viewMaxY = (chartHeight - currentTransform.y) / currentTransform.k;
                const rectX = (viewMinX - minX) * scale;
                const rectY = (viewMinY - minY) * scale;
                const rectW = Math.max((viewMaxX - viewMinX) * scale, 8);
                const rectH = Math.max((viewMaxY - viewMinY) * scale, 8);
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 82, 204, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.strokeRect(rectX, rectY, rectW, rectH);
                ctx.restore();
            }
            ctx.restore();
            miniMapState = { minX, minY, scale, width: canvas.width, height: canvas.height };
        }

        function refreshSidebarFocus() {
            let node = null;
            if (focusMode && focusedNodeId) {
                node = nodeMap.get(focusedNodeId);
            } else if (insightNode) {
                node = nodeMap.get(insightNode.id) || insightNode;
            }
            updateInsightPanel(node || null);
        }

        function setInsightNode(node, { persist = true } = {}) {
            if (persist) {
                insightNode = node ? node : null;
            }
            updateInsightPanel(node || (persist ? null : node));
        }

        function updateInsightPanel(node) {
            const title = document.getElementById('focusTitle');
            const meta = document.getElementById('focusMeta');
            const neighborsEl = document.getElementById('focusNeighbors');
            const descEl = document.getElementById('focusDescription');
            const pocsEl = document.getElementById('focusPocs');
            const neighborsSection = document.getElementById('focusNeighborsSection');
            if (!title || !meta || !neighborsEl || !descEl) return;
            meta.innerHTML = '';
            neighborsEl.innerHTML = '';
            descEl.textContent = '';
            if (pocsEl) {
                pocsEl.innerHTML = '';
                pocsEl.classList.add('focus-section-hidden');
            }
            refreshFocusStyles(node ? node.id : null);
            if (!node) {
                title.textContent = 'No selection yet';
                const li = document.createElement('li');
                li.textContent = 'Click a node to inspect details.';
                neighborsEl.appendChild(li);
                if (neighborsSection) neighborsSection.classList.remove('focus-section-hidden');
                if (pocsEl) pocsEl.classList.add('focus-section-hidden');
                activeFocusTab = 'overview';
                applyFocusTabState();
                return;
            }
            let displayTitle = node.name || node.id;
            const appendMeta = (label, value) => {
                const wrapper = document.createElement('div');
                const labelSpan = document.createElement('span');
                labelSpan.textContent = label;
                const valueStrong = document.createElement('strong');
                valueStrong.textContent = value;
                wrapper.appendChild(labelSpan);
                wrapper.appendChild(valueStrong);
                meta.appendChild(wrapper);
            };
            appendMeta('Type', node.type === 'actor' ? 'Actor' : 'CVE');
            const neighborIds = Array.from(adjacency.get(node.id) || []);
            appendMeta(node.type === 'actor' ? 'Linked CVEs' : 'Linked Actors', neighborIds.length.toString());
            if (node.type === 'cve') {
                const detail = node.details || {};
                const cveIdValue = detail.cveID || node.name || node.id;
                const cveId = cveIdValue ? String(cveIdValue) : 'Unknown';
                const githubPocs = getValidGithubPocs(node);
                const hasPocs = githubPocs.length > 0;
                const baseTitle = cveId;
                displayTitle = hasPocs ? `${baseTitle} 🚩` : baseTitle;
                appendMeta('CVE ID', cveId);
                const severityText = prettifySeverity((detail.severity || 'UNKNOWN').toUpperCase());
                appendMeta('Severity', severityText);
                appendMeta('Published', detail.dateAdded || 'Unknown');
                const desc = detail.shortDescription || 'No description available';
                const trimmed = desc.length > 240 ? `${desc.slice(0, 240)}...` : desc;
                descEl.textContent = trimmed;
                if (pocsEl) {
                    if (hasPocs) {
                        pocsEl.classList.remove('focus-section-hidden');
                        const titleEl = document.createElement('div');
                        titleEl.className = 'focus-pocs-title';
                        titleEl.textContent = 'GitHub PoCs';
                        pocsEl.appendChild(titleEl);
                        const listEl = document.createElement('ul');
                        listEl.className = 'focus-pocs-list';
                        githubPocs.forEach(url => {
                            const li = document.createElement('li');
                            const link = document.createElement('a');
                            link.href = url;
                            link.textContent = url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer nofollow ugc';
                            li.appendChild(link);
                            listEl.appendChild(li);
                        });
                        pocsEl.appendChild(listEl);
                    } else {
                        pocsEl.classList.add('focus-section-hidden');
                    }
                }
            } else {
                const severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, UNKNOWN: 0 };
                for (const id of neighborIds) {
                    const neighbor = nodeMap.get(id);
                    if (neighbor && neighbor.details) {
                        const sev = (neighbor.details.severity || 'UNKNOWN').toUpperCase();
                        if (severityCounts[sev] == null) severityCounts.UNKNOWN += 1;
                        else severityCounts[sev] += 1;
                    }
                }
                const summary = SEVERITY_ORDER.filter(level => severityCounts[level] > 0)
                    .map(level => `${severityCounts[level]} ${prettifySeverity(level)}`)
                    .join(', ');
                descEl.textContent = neighborIds.length ? `Exposure mix: ${summary || 'Unknown severities'}.` : 'No linked CVEs currently in view.';
                if (pocsEl) pocsEl.classList.add('focus-section-hidden');
                displayTitle = node.name || node.id;
            }
            const neighbors = neighborIds
                .map(id => nodeMap.get(id))
                .filter(Boolean)
                .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
            if (!neighbors.length) {
                const li = document.createElement('li');
                li.textContent = 'No linked nodes in the current view.';
                neighborsEl.appendChild(li);
            } else {
                neighbors.forEach(neighbor => {
                    const li = document.createElement('li');
                    if (node.type === 'actor') {
                        const sev = prettifySeverity((neighbor.details?.severity || 'UNKNOWN').toUpperCase());
                        li.textContent = `${neighbor.name || neighbor.id} (${sev})`;
                    } else {
                        li.textContent = neighbor.name || neighbor.id;
                    }
                    neighborsEl.appendChild(li);
                });
            }
            title.textContent = displayTitle;
            applyFocusTabState();
        }

        function refreshFocusStyles(activeId) {
            focusHighlightId = activeId || null;
            drawScene();
        }

        function refreshSearchMatchStyles() {
            drawScene();
        }

        function applySearchFocus() {
            const hasMatches = searchMatchIds && searchMatchIds.size > 0;
            searchVisibleNodeSet = null;
            searchHiddenActorSet = null;
            if (!hasMatches) {
                if (simulation) {
                    currentRenderNodes.forEach(d => {
                        if (d && d._searchFixed) {
                            d.fx = null;
                            d.fy = null;
                            d._searchFixed = false;
                        }
                    });
                }
                drawScene();
                return;
            }

            const actorMatches = new Set();
            const focusSet = new Set();
            searchMatchIds.forEach(id => {
                const node = nodeMap.get(id);
                if (!node) return;
                actorMatches.add(id);
                focusSet.add(id);
                const neighbors = adjacency.get(id) || new Set();
                neighbors.forEach(nid => focusSet.add(nid));
            });

            searchVisibleNodeSet = focusSet;
            searchHiddenActorSet = actorMatches;

            if (simulation) {
                currentRenderNodes.forEach(d => {
                    if (!d) return;
                    if (d.type === 'actor' && !actorMatches.has(d.id)) {
                        d.fx = d.x;
                        d.fy = d.y;
                        d._searchFixed = true;
                    } else if (d._searchFixed) {
                        d.fx = null;
                        d.fy = null;
                        d._searchFixed = false;
                    }
                });
                simulation.alpha(Math.max(simulation.alpha(), 0.08)).alphaTarget(0.02);
            }

            drawScene();
        }

        function attachCanvasInteractions() {
            if (!canvas) return;
            let lastPointerX = null;
            let lastPointerY = null;

            const pointerMove = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left - currentTransform.x) / currentTransform.k;
                const y = (event.clientY - rect.top - currentTransform.y) / currentTransform.k;
                const hit = hitTestNode(x, y);
                if (hit !== hoveredNode) {
                    hoveredNode = hit;
                    if (hoveredNode) {
                        tooltip.transition().duration(120).style('opacity', 0.9);
                        tooltip.text(hoveredNode.name)
                            .style('left', `${event.pageX + 5}px`)
                            .style('top', `${event.pageY - 28}px`);
                        canvas.style.cursor = isDraggingCanvas ? 'grabbing' : 'grab';
                    } else {
                        tooltip.transition().duration(180).style('opacity', 0);
                        if (!isDraggingCanvas) canvas.style.cursor = 'default';
                    }
                    drawScene();
                } else if (hoveredNode) {
                    tooltip.style('left', `${event.pageX + 5}px`).style('top', `${event.pageY - 28}px`);
                    canvas.style.cursor = isDraggingCanvas ? 'grabbing' : 'grab';
                } else if (!isDraggingCanvas) {
                    canvas.style.cursor = 'default';
                }
                if (pointerDownNode) {
                    if (!isDraggingCanvas && lastPointerX != null) {
                        const dx = Math.abs(event.clientX - lastPointerX);
                        const dy = Math.abs(event.clientY - lastPointerY);
                        if (dx > 2 || dy > 2) {
                            isDraggingCanvas = true;
                            pointerDownNode._dragging = true;
                            if (pointerDownNode._dragOffsetX == null) pointerDownNode._dragOffsetX = pointerDownNode.x - x;
                            if (pointerDownNode._dragOffsetY == null) pointerDownNode._dragOffsetY = pointerDownNode.y - y;
                        }
                    }
                    if (isDraggingCanvas) {
                        const offsetX = pointerDownNode._dragOffsetX || 0;
                        const offsetY = pointerDownNode._dragOffsetY || 0;
                        const newX = x + offsetX;
                        const newY = y + offsetY;
                        pointerDownNode.fx = newX;
                        pointerDownNode.fy = newY;
                        pointerDownNode.x = newX;
                        pointerDownNode.y = newY;
                        pointerDownNode._searchFixed = false;
                        if (simulation) simulation.alphaTarget(0.08);
                        drawScene();
                    }
                }
                lastPointerX = event.clientX;
                lastPointerY = event.clientY;
            };

            const pointerDown = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left - currentTransform.x) / currentTransform.k;
                const y = (event.clientY - rect.top - currentTransform.y) / currentTransform.k;
                const hit = hitTestNode(x, y);
                canvasWasPanned = false;
                if (hit) {
                    if (typeof event.stopPropagation === 'function') event.stopPropagation();
                    if (typeof event.preventDefault === 'function') event.preventDefault();
                    pointerDownNode = hit;
                    isDraggingCanvas = false;
                    hit.fx = hit.x;
                    hit.fy = hit.y;
                    hit._dragging = false;
                    hit._dragOffsetX = hit.x - x;
                    hit._dragOffsetY = hit.y - y;
                    hit.manualFixed = false;
                    if (simulation) simulation.alphaTarget(0.08);
                    canvas.style.cursor = 'grabbing';
                } else {
                    pointerDownNode = null;
                    isDraggingCanvas = false;
                    canvas.style.cursor = 'grab';
                }
                lastPointerX = event.clientX;
                lastPointerY = event.clientY;
                canvas.setPointerCapture(event.pointerId);
            };

            const pointerUp = (event) => {
                if (pointerDownNode) {
                    if (pointerDownNode._dragging) {
                        const finalX = pointerDownNode.fx;
                        const finalY = pointerDownNode.fy;
                        if (typeof finalX === 'number' && typeof finalY === 'number') {
                            pointerDownNode.x = finalX;
                            pointerDownNode.y = finalY;
                            pointerDownNode.fx = finalX;
                            pointerDownNode.fy = finalY;
                            pointerDownNode.manualFixed = true;
                            persistNodePositions();
                        }
                    } else {
                        handleCanvasClick(event, pointerDownNode);
                        if (!pointerDownNode.manualFixed) {
                            pointerDownNode.fx = null;
                            pointerDownNode.fy = null;
                        }
                    }
                    pointerDownNode._searchFixed = false;
                    pointerDownNode._dragging = false;
                    pointerDownNode._dragOffsetX = pointerDownNode._dragOffsetY = null;
                }
                pointerDownNode = null;
                isDraggingCanvas = false;
                canvas.releasePointerCapture(event.pointerId);
                if (simulation) simulation.alphaTarget(zoomTargetAlpha);
                lastPointerX = null;
                lastPointerY = null;
                canvas.style.cursor = 'default';
                drawScene();
            };
            const pointerLeave = () => {
                hoveredNode = null;
                pointerDownNode = null;
                tooltip.transition().duration(150).style('opacity', 0);
                isDraggingCanvas = false;
                if (simulation) simulation.alphaTarget(zoomTargetAlpha);
                lastPointerX = null;
                lastPointerY = null;
                canvas.style.cursor = 'default';
                canvasWasPanned = false;
                drawScene();
            };

            canvas.onpointerdown = pointerDown;
            canvas.onpointermove = pointerMove;
            canvas.onpointerup = pointerUp;
            canvas.onpointerleave = pointerLeave;
            canvas.addEventListener('click', (event) => {
                if (canvasWasPanned) {
                    canvasWasPanned = false;
                    return;
                }
                if (hitTestEvent(event)) return;
                if (spotlightNodeId) {
                    spotlightNodeId = null;
                    refreshSpotlightStyles();
                }
                canvasWasPanned = false;
            });
        }

        function handleCanvasClick(event, node) {
            if (!node) return;
            if ((event.altKey || event.metaKey) && node.manualFixed) {
                node.manualFixed = false;
                node.fx = null;
                node.fy = null;
                persistNodePositions();
                drawScene();
                return;
            }
            if (focusMode) {
                focusedNodeId = node.id;
                document.getElementById('exitFocus').style.display = 'inline-block';
                setStatus(`Focused on ${node.name}`);
                setInsightNode(node);
                visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.24 });
                updateStatusChips();
                return;
            }
            if (node.type === 'actor' || node.type === 'cve') {
                const alreadyFocused = spotlightNodeId === node.id;
                spotlightNodeId = alreadyFocused ? null : node.id;
                refreshSpotlightStyles();
            }
            setInsightNode(node);
            event.stopPropagation();
        }

        function hitTestEvent(event) {
            if (!canvas) return null;
            let clientX = event.clientX;
            let clientY = event.clientY;
            if (clientX == null && event.touches && event.touches.length) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }
            if (clientX == null || clientY == null) return null;
            const rect = canvas.getBoundingClientRect();
            const x = (clientX - rect.left - currentTransform.x) / currentTransform.k;
            const y = (clientY - rect.top - currentTransform.y) / currentTransform.k;
            return hitTestNode(x, y);
        }

        function hitTestNode(x, y) {
            let nearest = null;
            let minDist = Infinity;
            const maxSize = currentDegreeMap || new Map();
            for (const node of currentRenderNodes) {
                if (!node) continue;
                if (searchHiddenActorSet && node.type === 'actor' && searchHiddenActorSet.has(node.id)) continue;
                const dx = node.x - x;
                const dy = node.y - y;
                const r = Math.max(6, getRadius(node, maxSize));
                const dist = dx * dx + dy * dy;
                if (dist <= r * r && dist < minDist) {
                    minDist = dist;
                    nearest = node;
                }
            }
            return nearest;
        }

        function isPointerOverNode(event) {
            return !!hitTestEvent(event);
        }

        function refreshSpotlightStyles() {
            const activeId = spotlightNodeId;
            if (!activeId || !adjacency.has(activeId)) {
                spotlightNodeId = null;
                spotlightFocusSet = null;
                drawScene();
                return;
            }
            const focusSet = new Set([activeId]);
            const neighbors = adjacency.get(activeId) || new Set();
            neighbors.forEach(id => focusSet.add(id));
            spotlightFocusSet = focusSet;
            drawScene();
        }

        function clearActorSearchMatches({ reheatAlpha = 0.12 } = {}) {
            if (!searchMatchIds.size && !lastActorSearchTerm) return;
            searchMatchIds = new Set();
            lastActorSearchTerm = '';
            refreshSearchMatchStyles();
            applySearchFocus();
            refreshSpotlightStyles();
            if (simulation) {
                simulation.alpha(Math.max(simulation.alpha(), reheatAlpha)).alphaTarget(0.02);
            }
        }

        function performActorGraphSearch(term, { focus = true, updateStatus = true } = {}) {
            const raw = (term || '').trim();
            if (!raw) {
                clearActorSearchMatches();
                if (updateStatus) setStatus('Enter an actor name to search.');
                return false;
            }
            const normalized = raw.toLowerCase();
            const matches = allNodes.filter(n => n.type === 'actor' && (n.name || '').toLowerCase().includes(normalized));
            if (!matches.length) {
                clearActorSearchMatches();
                if (updateStatus) setStatus(`No actor matching "${raw}" in current graph.`);
                return false;
            }
            spotlightNodeId = null;
            searchMatchIds = new Set(matches.map(n => n.id));
            lastActorSearchTerm = raw;
            refreshSearchMatchStyles();
            applySearchFocus();
            refreshSpotlightStyles();
            let spotlightNode = null;
            if (focus) {
                spotlightNode = matches.find(n => (n.name || '').toLowerCase() === normalized) || matches[0];
                if (spotlightNode) {
                    setInsightNode(spotlightNode);
                    focusOnNodeById(spotlightNode.id);
                }
            }
            if (updateStatus) {
                const label = matches.length > 1 ? `${matches.length} actors` : (spotlightNode?.name || matches[0].name || matches[0].id);
                setStatus(`Found ${label} matching "${raw}".`);
            }
            drawScene();
            return true;
        }

        function applyFocusTabState() {
            const overview = document.getElementById('focusOverview');
            const neighborsSection = document.getElementById('focusNeighborsSection');
            if (overview) overview.classList.toggle('focus-section-hidden', activeFocusTab !== 'overview');
            if (neighborsSection) neighborsSection.classList.toggle('focus-section-hidden', activeFocusTab !== 'neighbors');
            const tabsContainer = document.getElementById('focusTabs');
            if (tabsContainer) {
                tabsContainer.querySelectorAll('.focus-tab').forEach(btn => {
                    const tab = btn.getAttribute('data-tab');
                    btn.classList.toggle('active', tab === activeFocusTab);
                });
            }
        }

        function setChipState(id, text, { variant = null, hidden = false } = {}) {
            const chip = document.getElementById(id);
            if (!chip) return;
            const label = chip.querySelector('.label-text');
            if (label) label.textContent = text;
            if (hidden) {
                chip.classList.add('hidden');
            } else {
                chip.classList.remove('hidden');
            }
            if (variant) {
                chip.setAttribute('data-variant', variant);
            } else {
                chip.removeAttribute('data-variant');
            }
        }

        function prettifySeverity(value) {
            if (!value || value === 'all') return 'All';
            return value.charAt(0) + value.slice(1).toLowerCase();
        }

        function getValidGithubPocs(node) {
            if (!node || !node.details) return [];
            const { githubPocs } = node.details;
            if (!Array.isArray(githubPocs)) return [];
            return githubPocs.filter(url => typeof url === 'string' && /^https?:\/\//i.test(url));
        }

        function setDelta(id, delta) {
            const el = document.getElementById(id);
            if (!el) return;
            el.classList.remove('positive', 'negative');
            if (delta == null || delta === 0) {
                el.textContent = '';
                return;
            }
            el.textContent = delta > 0 ? `+${delta}` : `${delta}`;
            el.classList.add(delta > 0 ? 'positive' : 'negative');
        }

        function updateStatusChips() {
            const totalText = pageInfo.total != null ? pageInfo.total : '?';
            const current = pageInfo.current || 0;
            setChipState('chipPage', `Page ${current}/${totalText}`, {
                hidden: current === 0 && pageInfo.total == null
            });

            setChipState('chipLayout', `Layout: ${organicMode ? 'Organic' : 'Structured'}`, {
                variant: organicMode ? 'warning' : null
            });

            const severityText = prettifySeverity(severityFilter);
            let severityVariant = null;
            if (severityFilter === 'CRITICAL') severityVariant = 'danger';
            else if (severityFilter === 'HIGH') severityVariant = 'warning';
            setChipState('chipSeverity', `Severity: ${severityText}`, { variant: severityVariant });

            setChipState('chipMinDegree', `Min CVEs: ${minDegree}`, {
                variant: minDegree > 0 ? 'warning' : null
            });

            const actorLabel = actorDisplayName ? `Actor: ${actorDisplayName}${filterActors ? ' (filtered)' : ''}` : (filterActors ? 'Actor: Filter On' : 'Actor: All');
            setChipState('chipActor', actorLabel, {
                variant: actorDisplayName || filterActors ? 'warning' : null
            });

            setChipState('chipLabels', `Labels: ${labelsOn ? 'On' : 'Off'}`, {
                variant: labelsOn ? null : 'warning'
            });

            let focusText = 'Focus Off';
            let focusVariant = null;
            if (focusMode) {
                focusVariant = 'warning';
                if (focusedNodeId) {
                    const focusName = (nodeMap.get(focusedNodeId) || {}).name || focusedNodeId;
                    focusText = `Focus: ${focusName}`;
                } else {
                    focusText = 'Focus Ready';
                }
            }
            setChipState('chipFocus', focusText, { variant: focusVariant });
            updateSeverityChips();
            updateTips();
        }

        function updateSeverityChips() {
            const container = document.getElementById('severityQuickFilters');
            if (!container) return;
            const buttons = container.querySelectorAll('.severity-chip');
            buttons.forEach(btn => {
                const val = btn.getAttribute('data-severity');
                btn.classList.toggle('active', (severityFilter || 'all') === val);
            });
        }

        function updateTips() {
            const list = document.getElementById('interactionTips');
            if (!list) return;
            list.innerHTML = '';
            const tips = [];
            tips.push('🚩 - Denotes CVE with PoCs');
            tips.push('Scroll or pinch to zoom, drag the background to pan.');
            tips.push('Use + / - keys or the toolbar buttons to adjust zoom. Press F to fit, R to reset.');
            if (!focusMode) {
                tips.push('Toggle Focus Mode to isolate a node and its neighborhood.');
            } else if (!focusedNodeId) {
                tips.push('Click any node to lock focus while Focus Mode is enabled.');
            } else {
                tips.push('Use the Exit Focus button or press Esc to leave the focused neighborhood.');
            }
            if (severityFilter !== 'all') {
                tips.push(`Severity filter is set to ${prettifySeverity(severityFilter)}. Click a severity chip to change or show all.`);
            }
            if (minDegree > 0) {
                tips.push(`Min CVEs slider is hiding actors linked to fewer than ${minDegree} CVEs.`);
            }
            for (const tip of tips.slice(0, 5)) {
                const li = document.createElement('li');
                li.textContent = tip;
                list.appendChild(li);
            }
        }

        function bindKeyboardShortcuts() {
            document.addEventListener('keydown', (event) => {
                if (event.defaultPrevented) return;
                const active = document.activeElement;
                if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) {
                    return;
                }
                switch (event.key) {
                    case '+':
                    case '=':
                        zoomBy(1.2);
                        event.preventDefault();
                        break;
                    case '-':
                    case '_':
                        zoomBy(1 / 1.2);
                        event.preventDefault();
                        break;
                    case 'f':
                    case 'F':
                        fitToScreen();
                        event.preventDefault();
                        break;
                    case 'r':
                    case 'R':
                        if (canvas && zoomBehavior) {
                            d3.select(canvas).transition().duration(250).call(zoomBehavior.transform, d3.zoomIdentity);
                        }
                        event.preventDefault();
                        break;
                    case 'Escape':
                        if (focusMode && focusedNodeId) {
                            focusedNodeId = null;
                            document.getElementById('exitFocus').style.display = 'none';
                            visualizeData({ nodes: allNodes, links: allLinks }, { reheatAlpha: 0.22 });
                            updateStatusChips();
                            refreshSidebarFocus();
                        }
                        break;
                    default:
                        break;
                }
            });
        }

        // Status + progress
        function setStatus(text) { document.getElementById('statusText').textContent = text; }
        function updateCounts() { document.getElementById('countsText').textContent = `Nodes: ${allNodes.length}, Links: ${allLinks.length}`; }
        function showProgress() { document.getElementById('progressContainer').style.display = 'block'; }
        function hideProgress() { document.getElementById('progressContainer').style.display = 'none'; }
        function resetProgress() { updateProgress(0, 1); hideProgress(); }
        function updateProgress(page, total) {
            const pct = Math.max(0, Math.min(100, Math.round((page / total) * 100)));
            const bar = document.getElementById('loadProgress');
            bar.style.width = pct + '%';
            bar.textContent = pct + '%';
            bar.setAttribute('aria-valuenow', pct.toString());
        }

        // Zoom helpers
        function zoomBy(k) {
            if (!canvas || !zoomBehavior) return;
            d3.select(canvas).transition().duration(200).call(zoomBehavior.scaleBy, k);
        }
        function fitToScreen() {
            if (!canvas || !zoomBehavior) return;
            if (!currentRenderNodes.length) return;
            const xs = currentRenderNodes.map(n => n.x);
            const ys = currentRenderNodes.map(n => n.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const width = maxX - minX || 1;
            const height = maxY - minY || 1;
            const parent = canvas.getBoundingClientRect();
            const fullWidth = parent.width;
            const fullHeight = parent.height;
            const scale = Math.min(1.2, 0.9 / Math.max(width / fullWidth, height / fullHeight));
            const transform = d3.zoomIdentity
                .translate(fullWidth / 2, fullHeight / 2)
                .scale(scale)
                .translate(-(minX + width / 2), -(minY + height / 2));
            d3.select(canvas).transition().duration(400).call(zoomBehavior.transform, transform);
        }

        // Export snapshot
        function exportSVG() {
            if (!canvas) return;
            const link = document.createElement('a');
            link.href = canvas.toDataURL('image/png');
            link.download = 'kev_graph.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function applyForces(degreeMap, width, height, { reheatAlpha = 0.12 } = {}) {
            if (!simulation) return;
            const linkForce = simulation.force('link');
            const spacingScalar = 1 + spacingStrength / 50;
            const collisionPadding = spacingStrength / 6;
            if (linkForce && linkForce.distance) {
                linkForce.distance(d => getLinkDistance(d) * spacingScalar).strength(organicMode ? 0.45 : 0.55);
            }
            const chargeForce = simulation.force('charge');
            if (chargeForce && chargeForce.strength) {
                const baseCharge = (organicMode ? -150 : -75) * spacingScalar;
                chargeForce.strength(baseCharge);
            }
            const collForce = simulation.force('collision');
            if (collForce && collForce.radius) collForce.radius(d => getRadius(d, degreeMap) + (organicMode ? 2 : 6) + collisionPadding);
            if (organicMode) {
                simulation.force('x', null);
            } else {
                simulation.force('x', d3.forceX(d => d.type === 'actor' ? width * 0.3 : width * 0.7).strength(0.05));
            }
            const desiredAlpha = Math.min(Math.max(reheatAlpha, 0.03), 0.16);
            simulation.alpha(Math.max(simulation.alpha(), desiredAlpha)).alphaTarget(0).restart();
        }

        // Focus by node id (best-effort)
        function focusOnNodeById(id) {
            const match = allNodes.find(n => n.id === id);
            if (!match || !canvas || !zoomBehavior) return;
            const cx = match.x || 0;
            const cy = match.y || 0;
            const parent = canvas.getBoundingClientRect();
            const transform = d3.zoomIdentity.translate(parent.width / 2, parent.height / 2).scale(1.5).translate(-cx, -cy);
            d3.select(canvas).transition().duration(300).call(zoomBehavior.transform, transform);
        }

        // Initialize from URL params if present
        (function initFromQuery() {
            try {
                const params = new URLSearchParams(window.location.search);
                const actor = params.get('actor');
                const p = parseInt(params.get('per_page') || '0', 10);
                if (p) { perPage = Math.max(1, Math.min(100, p)); document.getElementById('perPage').value = perPage; }
                if (actor) {
                    document.getElementById('actorSearch').value = actor;
                    actorDisplayName = actor;
                    searchedActor = actor.toLowerCase();
                    updateStatusChips();
                    fetchDataByActor(searchedActor);
                }
            } catch { /* ignore */ }
        })();

        updateGraphSnapshot([], []);
        scheduleMiniMapRender([]);
        updateStatusChips();
        window.addEventListener('beforeunload', persistNodePositions);
        refreshSidebarFocus();
        bindKeyboardShortcuts();

    </script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>
        
